<!DOCTYPE html>
<html class="no-js" lang="en" data-useragent="Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>fabric 学习笔记</title>
        <meta
            name="description"
            content="The Jekyll AsciiDoc Quickstart project is a leg-up in starting your own website hosted on GitHub with content based in AsciiDoc."
        />
        <meta name="author" content="Your name goes here" />
        <meta name="copyright" content="Maybe consider a Creative Commons license" />
        <link rel="stylesheet" href="/css/foundation.css" />
        <link rel="stylesheet" href="/css/font-awesome.css" />
        <link rel="stylesheet" href="/css/asciidoctor.css" />
        <link rel="stylesheet" href="/css/custom.css" />
        <link rel="stylesheet" href="/css/prettify.min.css" />
        <script src="js/vendor/modernizr.js"></script>
        <script src="js/toc.js"></script>
    </head>
    <body>
        <!-- Main Page Content and Sidebar -->

        <!-- Sidebar -->

        <div class="post with-summary">
            <div class="post-summary">
                <div class="search-container">
                    <!-- <a href="/">fabric source</a> -->
                    <input id="search_box" type="search" placeholder="Search..." />
                    <i class="fa fa-search"></i>
                </div>
                <ul class="category">
                    
                    <li>
                        <a>原理</a>
                    </li>
                    <ul class="post">
                         
                        <li>
                            <a href="/allposts/principle/workflow">工作流程</a>
                        </li>
                        
                    </ul>
                    
                    <li>
                        <a>调试</a>
                    </li>
                    <ul class="post">
                         
                        <li>
                            <a href="/allposts/debug/overview">概览</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/debug/orderer-config">orderder 配置</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/debug/orderer-genesisblock">orderer genesisblock</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/debug/create-channel">create channel</a>
                        </li>
                        
                    </ul>
                    
                    <li>
                        <a>源码</a>
                    </li>
                    <ul class="post">
                         
                        <li>
                            <a href="/allposts/source/abbreviation">缩写</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/source/directory">目录</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/source/peer">peer</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/source/orderer">orderer</a>
                        </li>
                        
                    </ul>
                    
                    <li>
                        <a>第三方库</a>
                    </li>
                    <ul class="post">
                         
                        <li>
                            <a href="/allposts/third-lib/jww">jww</a>
                        </li>
                        
                        <li>
                            <a href="/allposts/third-lib/kingpin">kingpin</a>
                        </li>
                        
                    </ul>
                    
                </ul>
            </div>

            <!-- End Sidebar -->

            <!-- Main Blog Content -->
            <div class="post-body" role="content">
                <div class="body-container">
                    <div class="page-header">
                        <a class="btn pull-left">
                            <i class="fa fa-align-justify"></i>
                        </a>
                        <div class="project-title">
                            <div class="project-title-inner">
                                <a href="/">
                                    fabric source
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="content-container">
                        <div>
                            <div id="content" class="page-inner">
                                <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#工作流程">工作流程</a></li>
<li><a href="#概览">概览</a>
<ul class="sectlevel2">
<li><a href="#准备工作">准备工作</a></li>
<li><a href="#步骤">步骤</a></li>
<li><a href="#调试准备">调试准备</a>
<ul class="sectlevel3">
<li><a href="#第_1_步">第 1 步</a></li>
<li><a href="#第_2_步">第 2 步</a></li>
<li><a href="#第_3_步">第 3 步</a></li>
<li><a href="#第_4_步">第 4 步</a></li>
</ul>
</li>
<li><a href="#调试_orderer">调试 orderer</a></li>
<li><a href="#调试_peer_start">调试 peer start</a></li>
<li><a href="#调试_create_channel">调试 create channel</a></li>
<li><a href="#调试_join_channel">调试 join channel</a></li>
<li><a href="#调试_install_chaincode">调试 install chaincode</a></li>
</ul>
</li>
<li><a href="#orderer_配置">orderer 配置</a>
<ul class="sectlevel2">
<li><a href="#加载配置">加载配置</a>
<ul class="sectlevel3">
<li><a href="#配置文件与环境变量的关系">配置文件与环境变量的关系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#create_channel">create channel</a>
<ul class="sectlevel2">
<li><a href="#命令_peer_channel_create">命令 peer channel create</a></li>
<li><a href="#grpc_的使用">gRPC 的使用</a>
<ul class="sectlevel3">
<li><a href="#atomicbroadcast">AtomicBroadcast</a></li>
<li><a href="#atomicbroadcastclient">AtomicBroadcastClient</a></li>
<li><a href="#ordererclient">OrdererClient</a></li>
<li><a href="#消息的发出">消息的发出</a></li>
<li><a href="#atomicbroadcastserver">AtomicBroadcastServer</a></li>
</ul>
</li>
<li><a href="#solo">solo</a>
<ul class="sectlevel3">
<li><a href="#处理消息的方法">处理消息的方法</a></li>
<li><a href="#processor">processor</a></li>
<li><a href="#为什么使用的是_solo_呢">为什么使用的是 solo 呢</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orderer_genesisblock">orderer genesisblock</a>
<ul class="sectlevel2">
<li><a href="#读取创世块信息">读取创世块信息</a></li>
<li><a href="#创建账本文件夹">创建账本文件夹</a></li>
<li><a href="#创建默认_channel">创建默认 channel</a></li>
</ul>
</li>
<li><a href="#缩写">缩写</a></li>
<li><a href="#目录">目录</a></li>
<li><a href="#peer">peer</a></li>
<li><a href="#jww">jww</a>
<ul class="sectlevel2">
<li><a href="#特点">特点</a></li>
<li><a href="#级别">级别</a></li>
<li><a href="#示例">示例</a></li>
<li><a href="#意义是什么">意义是什么?</a></li>
</ul>
</li>
<li><a href="#kingpin">kingpin</a>
<ul class="sectlevel2">
<li><a href="#示例_1">示例 1</a></li>
<li><a href="#示例_2">示例 2</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="工作流程">工作流程</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/diag-61fa50590eabf0f9b32c846ee61d2837.svg" alt="diag 61fa50590eabf0f9b32c846ee61d2837" width="496" height="405">
</div>
<div class="title">Figure 1. 交易流程时序图</div>
</div>
<div class="dlist">
<div class="title">交易流程</div>
<dl>
<dt class="hdlist1">(1)</dt>
<dd>
<p>客户端通过 SDK 接口向 <strong>背书节点</strong> 发送交易信息</p>
</dd>
<dt class="hdlist1">(2)</dt>
<dd>
<p>每个 <strong>背书节点</strong> 模拟处理交易，并不会把交易信息写入账本。<strong>背书节点</strong> 会验证交易的合法性，并对交易签名，返回给 <strong>client</strong>。此时没有完成全网共识，各个 <strong>client</strong> 的交易顺序没有确定，可能存在 <strong>双花</strong> 问题，还不算是 "有效的交易"。</p>
</dd>
<dt class="hdlist1">(3)</dt>
<dd>
<p><strong>client</strong> 将签名后的交易发送给 <strong>order servic</strong> 集群进行交易排序和打包。<strong>order servic</strong> 集群通过共识算法对交易进行排序，打包成区块。</p>
</dd>
<dt class="hdlist1">(4)</dt>
<dd>
<p><strong>order servic</strong> 将打包后的区块广播发送给 <strong>提交节点</strong>，由其做最后的验证，并写入链。</p>
</dd>
</dl>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<strong>order servic</strong> 在发给 <strong>提交节点</strong> 的同时，是否也发给了 <strong>背书节点</strong> ? 待确认
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="概览">概览</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="准备工作">准备工作</h3>
<div class="ulist">
<ul>
<li>
<p>fabric 源码，fabric-samples 源码</p>
</li>
<li>
<p>GoLand (golang IDE)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="步骤">步骤</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 GoLand 打开 fabric 源码</p>
</li>
<li>
<p>新建 dev-network 目录</p>
</li>
<li>
<p>把 sampleconfig 下的所有文件复制到 dev-network</p>
</li>
<li>
<p>修改 core.yaml 中 fileSystemPath = fabric源码目录下dev-network/production/peer(绝对路径)</p>
</li>
<li>
<p>修改 orderer.yaml 中 Location = fabric源码目录下dev-network/production/orderer(绝对路径)</p>
</li>
<li>
<p>在 dev-network 新建 config，并复制 fabric-samples 模块 chaincode-docker-devmode下的 myc.tx 和 orderer.block</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="调试准备">调试准备</h3>
<div class="sect3">
<h4 id="第_1_步">第 1 步</h4>
<div class="paragraph">
<p>点击菜单项 Run/Edit Configurations</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2019-06-25-14-03-43.png" alt="2019 06 25 14 03 43" width="500">
</div>
<div class="title">Figure 2. 点击菜单项 Run/Edit Configurations</div>
</div>
</div>
<div class="sect3">
<h4 id="第_2_步">第 2 步</h4>
<div class="paragraph">
<p>点击弹出窗口左上交的 + 按钮</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2019-06-25-14-09-37.png" alt="2019 06 25 14 09 37" width="500">
</div>
<div class="title">Figure 3. 弹出窗口左侧 + 按钮</div>
</div>
<div class="paragraph">
<p>点击 + 按钮之后，会弹出若干 configuration 的选项，选择 Go Build</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2019-06-25-14-12-24.png" alt="2019 06 25 14 12 24" width="500">
</div>
<div class="title">Figure 4. configuration 的选项</div>
</div>
</div>
<div class="sect3">
<h4 id="第_3_步">第 3 步</h4>
<div class="imageblock">
<div class="content">
<img src="images/2019-06-25-14-53-49.png" alt="2019 06 25 14 53 49" width="500">
</div>
<div class="title">Figure 5. configuration 的具体设置</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Name 是 configuration 的名字，与左侧的列表中的名字相对应，便于调试的时候进行选择。</p>
</li>
<li>
<p>Run kind 包括 Directory, Package, File 几种类型</p>
</li>
<li>
<p>Files 是真正需要去编译的文件，如果 Run kind 选择了 File，那么 Files 需要指定到某一个作为入口的 main.go 文件</p>
</li>
<li>
<p>Environment 是环境变量。除了系统级别的环境变量意外，这里可以以 configuration 为单位设置环境变量，这样就更加灵活，互相之间不会干扰，也不会污染系统环境。多个环境变量之间用分号 <strong>;</strong> 隔开</p>
</li>
<li>
<p>Program arguments 是程序运行时需要的命令行参数</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="第_4_步">第 4 步</h4>
<div class="imageblock">
<div class="content">
<img src="images/2019-06-26-10-44-50.png" alt="2019 06 26 10 44 50" width="500">
</div>
<div class="title">Figure 6. 创建好的 configurations</div>
</div>
<div class="paragraph">
<p>选择一个 configuration，然后点击红色的按钮，即可开始调试</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="调试_orderer">调试 orderer</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">入口位置</dt>
<dd>
<p>orderer/main.go main 函数</p>
</dd>
<dt class="hdlist1">Environment</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</p>
</li>
<li>
<p>ORDERER_GENERAL_GENESISMETHOD=file</p>
</li>
<li>
<p>ORDERER_GENERAL_GENESISFILE=fabric源码目录下dev-network/config/orderer.block(绝对路径)</p>
</li>
<li>
<p>ORDERER_GENERAL_LOCALMSPID=DEFAULT</p>
</li>
<li>
<p>ORDERER_GENERAL_LOCALMSPDIR=fabric源码目录下dev-network/msp(绝对路径)</p>
</li>
<li>
<p>FABRIC_CFG_PATH=fabric源码目录下dev-network(绝对路径)</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="调试_peer_start">调试 peer start</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">入口位置</dt>
<dd>
<p>peer/main.go main 函数</p>
</dd>
<dt class="hdlist1">Program arguments</dt>
<dd>
<p>node start --peer-chaincodedev=true</p>
</dd>
<dt class="hdlist1">Environment</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CORE_PEER_LOCALMSPID=DEFAULT</p>
</li>
<li>
<p>CORE_PEER_ID=peer</p>
</li>
<li>
<p>CORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)</p>
</li>
<li>
<p>CORE_PEER_ADDRESS=127.0.0.1:7051</p>
</li>
<li>
<p>FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="调试_create_channel">调试 create channel</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">入口位置</dt>
<dd>
<p>peer/main.go main 函数</p>
</dd>
<dt class="hdlist1">Program arguments</dt>
<dd>
<p>channel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050
　　</p>
</dd>
<dt class="hdlist1">Environment</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CORE_PEER_LOCALMSPID=DEFAULT</p>
</li>
<li>
<p>CORE_PEER_ID=cli</p>
</li>
<li>
<p>CORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)</p>
</li>
<li>
<p>CORE_PEER_ADDRESS=127.0.0.1:7051</p>
</li>
<li>
<p>FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="调试_join_channel">调试 join channel</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">入口位置</dt>
<dd>
<p>peer/main.go main 函数</p>
</dd>
<dt class="hdlist1">Program arguments</dt>
<dd>
<p>channel join -b myc.block</p>
</dd>
<dt class="hdlist1">Environment</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CORE_PEER_LOCALMSPID=DEFAULT</p>
</li>
<li>
<p>CORE_PEER_ID=cli</p>
</li>
<li>
<p>CORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)</p>
</li>
<li>
<p>CORE_PEER_ADDRESS=127.0.0.1:7051</p>
</li>
<li>
<p>FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="调试_install_chaincode">调试 install chaincode</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">入口位置</dt>
<dd>
<p>peer/main.go main 函数</p>
</dd>
<dt class="hdlist1">Program arguments</dt>
<dd>
<p>chaincode install -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -n mycc -v 1.0
　　</p>
</dd>
<dt class="hdlist1">Environment</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>CORE_PEER_LOCALMSPID=DEFAULT</p>
</li>
<li>
<p>CORE_PEER_ID=cli</p>
</li>
<li>
<p>CORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)</p>
</li>
<li>
<p>CORE_PEER_ADDRESS=127.0.0.1:7051</p>
</li>
<li>
<p>FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
其余部分待补充
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="orderer_配置">orderer 配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>orderer 启动时，从 /orderer/main.go 入口</p>
</div>
<div class="listingblock">
<div class="title">/orderer/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func main() {
	server.Main()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用的是 ./orderer/common/server/main.go</p>
</div>
<div class="listingblock">
<div class="title">/orderer/common/server/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Main() {
	fullCmd := kingpin.MustParse(app.Parse(os.Args[1:]))

	// "version" command
	if fullCmd == version.FullCommand() {
		fmt.Println(metadata.GetVersionInfo())
		return
	}

	conf, err := localconfig.Load() <i class="conum" data-value="1"></i><b>(1)</b>
	if err != nil {
		logger.Error("failed to parse config: ", err)
		os.Exit(1)
	}
	initializeLogging()
	initializeLocalMsp(conf)

	prettyPrintStruct(conf)
	Start(fullCmd, conf)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>加载配置</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="加载配置">加载配置</h3>
<div class="listingblock">
<div class="title">/orderer/common/localconfig/config.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Load() (*TopLevel, error) {
	config := viper.New()
	coreconfig.InitViper(config, "orderer") <i class="conum" data-value="1"></i><b>(1)</b>
	config.SetEnvPrefix(Prefix) <i class="conum" data-value="2"></i><b>(2)</b>
	config.AutomaticEnv() <i class="conum" data-value="3"></i><b>(3)</b>
	replacer := strings.NewReplacer(".", "_")
	config.SetEnvKeyReplacer(replacer)

	if err := config.ReadInConfig(); err != nil {
		return nil, fmt.Errorf("Error reading configuration: %s", err)
	}

	var uconf TopLevel
	if err := viperutil.EnhancedExactUnmarshal(config, &amp;uconf); err != nil {
		return nil, fmt.Errorf("Error unmarshaling config into struct: %s", err)
	}

	uconf.completeInitialization(filepath.Dir(config.ConfigFileUsed()))
	return &amp;uconf, nil
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>初始化一个 viper 实例，制定配置文件名字为 orderer</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置环境变量前缀，这里前缀是 <strong>ORDERER</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>自动读取 <strong>环境变量</strong></td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="配置文件与环境变量的关系">配置文件与环境变量的关系</h4>
<div class="paragraph">
<p>简单的说，<strong>环境变量会覆盖配置文件中的配置项</strong>，这样可以在不改变配置文件的前提下，做某些调整，非常方便，下面看下具体过程。</p>
</div>
<div class="paragraph">
<p>进入 coreconfig.InitViper 内部</p>
</div>
<div class="listingblock">
<div class="title">/core/config/config.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func InitViper(v *viper.Viper, configName string) error {
	var altPath = os.Getenv("FABRIC_CFG_PATH") <i class="conum" data-value="1"></i><b>(1)</b>
	if altPath != "" {
		// If the user has overridden the path with an envvar, its the only path
		// we will consider

		if !dirExists(altPath) {
			return fmt.Errorf("FABRIC_CFG_PATH %s does not exist", altPath)
		}

		AddConfigPath(v, altPath)
	} else {
		// If we get here, we should use the default paths in priority order:
		//
		// *) CWD
		// *) /etc/hyperledger/fabric

		// CWD
		AddConfigPath(v, "./")

		// And finally, the official path
		if dirExists(OfficialPath) {
			AddConfigPath(v, OfficialPath)
		}
	}

	// Now set the configuration file.
	if v != nil {
		v.SetConfigName(configName)
	} else {
		viper.SetConfigName(configName)
	}

	return nil
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>获取环境变量 <strong>FABRIC_CFG_PATH</strong> 的值</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>FABRIC_CFG_PATH</strong> 指定了配置文件所在的位置，若未指定，则为当前文件夹</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>viper 支持的配置文件扩展名有 7 种</p>
</div>
<div class="listingblock">
<div class="title">github.com/spf13/viper/viper.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">// Universally supported extensions.
var SupportedExts []string = []string{"json", "toml", "yaml", "yml", "properties", "props", "prop"}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>orderer 读取的是 <strong>orderer.yaml</strong>，以 <strong>GenesisMethod</strong> 为例，来看一下配置文件和环境变量的关系</p>
</div>
<div class="paragraph">
<p>配置文件中 GenesisMethod 的值是 provisional</p>
</div>
<div class="listingblock">
<div class="title">orderer.yaml</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="yaml">General:
	...
	GenesisMethod: provisional
	...</code></pre>
</div>
</div>
<div class="paragraph">
<p>环境变量配置中 GenesisMethod 的值是 file</p>
</div>
<div class="listingblock">
<div class="title">环境变量配置</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">ORDERER_GENERAL_GENESISMETHOD=file</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
环境变量命名规则 <strong>前缀_项_子项_以此类推，大写</strong>，orderer 配置文件的前缀是 orderer，General 的子项 GenesisMethod 按照规则来，就是 ORDERER_GENERAL_GENESISMETHOD
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>fabric 会先读取配置文件的内容，然后在环境变量中找相应的配置项，如果存在，环境变量会覆盖掉配置文件中的项</p>
</div>
<div class="paragraph">
<p>环境变量覆盖配置文件项的位置</p>
</div>
<div class="listingblock">
<div class="title">github.com/spf13/viper/viper.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func (v *Viper) find(key string) interface{} {
	...
	if v.automaticEnvApplied { <i class="conum" data-value="1"></i><b>(1)</b>
		// even if it hasn't been registered, if automaticEnv is used,
		// check any Get request
		if val = v.getEnv(v.mergeWithEnvPrefix(key)); val != "" {
			jww.TRACE.Println(key, "found in environment with val:", val)
			return val
		}
	}
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>v.automaticEnvApplied 在方法 config.AutomaticEnv() 中被设置为 true</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="create_channel">create channel</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="命令_peer_channel_create">命令 peer channel create</h3>
<div class="paragraph">
<p>命令如下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">peer channel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
channel 是 peer 的子命令，create 是 channel 的子命令
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>create channel 是 peer 节点执行的命令，入口处在 /peer/main.go</p>
</div>
<div class="listingblock">
<div class="title">/peer/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func main() {
	...
	mainCmd.AddCommand(channel.Cmd(nil)) <i class="conum" data-value="1"></i><b>(1)</b>
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>为 mainCmd 添加了 channel 子命令</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>mainCmd 就是 <strong>peer</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">var mainCmd = &amp;cobra.Command{
	Use: "peer"}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>channel 里面什么样呢</p>
</div>
<div class="listingblock">
<div class="title">/peer/channel/channel.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Cmd(cf *ChannelCmdFactory) *cobra.Command {
	...
	channelCmd.AddCommand(createCmd(cf)) <i class="conum" data-value="1"></i><b>(1)</b>
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加了 <strong>create</strong> 子命令</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>createCmd 里面</p>
</div>
<div class="listingblock">
<div class="title">/peer/channel/create.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func createCmd(cf *ChannelCmdFactory) *cobra.Command {
	createCmd := &amp;cobra.Command{
		Use:   "create",
		Short: "Create a channel",
		Long:  "Create a channel and write the genesis block to a file.",
		RunE: func(cmd *cobra.Command, args []string) error {
			return create(cmd, args, cf) <i class="conum" data-value="1"></i><b>(1)</b>
		},
	}
	flagList := []string{
		"channelID",
		"file",
		"outputBlock",
		"timeout",
	}
	attachFlags(createCmd, flagList)

	return createCmd
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>create channel 实际执行的是 <strong>create</strong> 方法</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">/peer/channel/create.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func create(cmd *cobra.Command, args []string, cf *ChannelCmdFactory) error {
	...
	if cf == nil {
		cf, err = InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererRequired) <i class="conum" data-value="1"></i><b>(1)</b>
		...
	}
	return executeCreate(cf)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建了一个 <strong>ChannelCmdFactory</strong> 对象</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>看一下 <strong>ChannelCmdFactory</strong> 结构</p>
</div>
<div class="listingblock">
<div class="title">/peer/channel/channel.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type ChannelCmdFactory struct {
	EndorserClient   pb.EndorserClient
	Signer           msp.SigningIdentity
	BroadcastClient  common.BroadcastClient <i class="conum" data-value="1"></i><b>(1)</b>
	DeliverClient    deliverClientIntf
	BroadcastFactory BroadcastClientFactory <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>BroadcastClient 用来通信</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>BroadcastFactory 是一个方法，用来得到 BroadcastClient 对象</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">/peer/common/broadcastclient.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type BroadcastClient interface { <i class="conum" data-value="1"></i><b>(1)</b>
	Send(env *cb.Envelope) error
	Close() error
}

type broadcastClient struct { <i class="conum" data-value="2"></i><b>(2)</b>
	client ab.AtomicBroadcast_BroadcastClient <i class="conum" data-value="3"></i><b>(3)</b>
}

...

func (s *broadcastClient) Send(env *cb.Envelope) error {
	...
}

func (s *broadcastClient) Close() error {
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>BroadcastClient 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>broadcastClient 实现了 BroadcastClient 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>真正完成 Send, Close 动作的是 ab.AtomicBroadcast_BroadcastClient</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="grpc_的使用">gRPC 的使用</h3>
<div class="sect3">
<h4 id="atomicbroadcast">AtomicBroadcast</h4>
<div class="paragraph">
<p>/protos/orderer/ab.proto 文件定义了 AtomicBroadcast 的原型</p>
</div>
<div class="listingblock">
<div class="title">protos/orderer/ab.proto</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="pb">...
service AtomicBroadcast {
    rpc Broadcast(stream common.Envelope) returns (stream BroadcastResponse) {}

    rpc Deliver(stream common.Envelope) returns (stream DeliverResponse) {}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="atomicbroadcastclient">AtomicBroadcastClient</h4>
<div class="paragraph">
<p>/protos/orderer/ab.proto 经过 gPRC 编译后得到 /protos/orderer/ab.pb.go，里面包括 2 个部分  <strong>AtomicBroadcastClient</strong>，<strong>AtomicBroadcastServer</strong>，这里先看 <strong>AtomicBroadcastClient</strong></p>
</div>
<div class="listingblock">
<div class="title">/protos/orderer/ab.pb.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type AtomicBroadcastClient interface { <i class="conum" data-value="1"></i><b>(1)</b>
	Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error)
	Deliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error)
}

type atomicBroadcastClient struct { <i class="conum" data-value="2"></i><b>(2)</b>
	cc *grpc.ClientConn
}

func NewAtomicBroadcastClient(cc *grpc.ClientConn) AtomicBroadcastClient { <i class="conum" data-value="3"></i><b>(3)</b>
	return &amp;atomicBroadcastClient{cc}
}

func (c *atomicBroadcastClient) Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error) {
	...
}

type AtomicBroadcast_BroadcastClient interface { <i class="conum" data-value="4"></i><b>(4)</b>
	Send(*common.Envelope) error
	Recv() (*BroadcastResponse, error)
	grpc.ClientStream
}

type atomicBroadcastBroadcastClient struct { <i class="conum" data-value="5"></i><b>(5)</b>
	grpc.ClientStream
}

func (x *atomicBroadcastBroadcastClient) Send(m *common.Envelope) error {
	...
}

func (x *atomicBroadcastBroadcastClient) Recv() (*BroadcastResponse, error) {
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>AtomicBroadcastClient 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>atomicBroadcastClient 实现了 AtomicBroadcastClient 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个 atomicBroadcastClient 实例</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>AtomicBroadcast_BroadcastClient 接口是针对 AtomicBroadcastClient 中的 Broadcast 动作的客户端</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>atomicBroadcastBroadcastClient 实现了 AtomicBroadcast_BroadcastClient 接口</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
AtomicBroadcast_DeliverClient 也是有的，与 AtomicBroadcast_BroadcastClient 类似，不再缀述
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ordererclient">OrdererClient</h4>
<div class="listingblock">
<div class="title">/peer/common/ordererclient.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type OrdererClient struct { <i class="conum" data-value="1"></i><b>(1)</b>
	commonClient
}

func NewOrdererClientFromEnv() (*OrdererClient, error) { <i class="conum" data-value="2"></i><b>(2)</b>
	address, override, clientConfig, err := configFromEnv("orderer") <i class="conum" data-value="3"></i><b>(3)</b>
	...
}

func (oc *OrdererClient) Broadcast() (ab.AtomicBroadcast_BroadcastClient, error) {
	...
}

func (oc *OrdererClient) Deliver() (ab.AtomicBroadcast_DeliverClient, error) {
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>OrdererClient 实现了 AtomicBroadcastClient 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>NewOrdererClientFromEnv 创建了一 OrdererClient 实例</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取了关于 orderer 的配置，如地址，超时时间等</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前面提到过 InitCmdFactory 方法</p>
</div>
<div class="listingblock">
<div class="title">/peer/chaincode/common.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func InitCmdFactory(cmdName string, isEndorserRequired, isOrdererRequired bool) (*ChaincodeCmdFactory, error) {
	...
	if isOrdererRequired {
		...
		broadcastClient, err = common.GetBroadcastClientFnc()
		...
	}
	...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">/peer/chaincode/common.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func init() {
	...
	GetBroadcastClientFnc = GetBroadcastClient
	...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">/peer/common/broadcastclient.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func GetBroadcastClient() (BroadcastClient, error) {
	oc, err := NewOrdererClientFromEnv() <i class="conum" data-value="1"></i><b>(1)</b>
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>调用了 OrdererClient 中的 NewOrdererClientFromEnv 方法</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="消息的发出">消息的发出</h4>
<div class="listingblock">
<div class="title">peer/channel/create.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func sendCreateChainTransaction(cf *ChannelCmdFactory) error {
	...
	defer broadcastClient.Close()
	err = broadcastClient.Send(chCrtEnv) <i class="conum" data-value="1"></i><b>(1)</b>

	return err
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>broadcastClient.Send 方法实际上调用了 gRPC，从 peer 节点发送消息给了 orderer 服务</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="atomicbroadcastserver">AtomicBroadcastServer</h4>
<div class="listingblock">
<div class="title">/protos/orderer/ab.pb.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type AtomicBroadcastServer interface {
	Broadcast(AtomicBroadcast_BroadcastServer) error
	Deliver(AtomicBroadcast_DeliverServer) error
}

func RegisterAtomicBroadcastServer(s *grpc.Server, srv AtomicBroadcastServer) { <i class="conum" data-value="1"></i><b>(1)</b>
	s.RegisterService(&amp;_AtomicBroadcast_serviceDesc, srv)
}

func _AtomicBroadcast_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtomicBroadcastServer).Broadcast(&amp;atomicBroadcastBroadcastServer{stream}) <i class="conum" data-value="3"></i><b>(3)</b>
}
...
var _AtomicBroadcast_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderer.AtomicBroadcast",
	HandlerType: (*AtomicBroadcastServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Broadcast",
			Handler:       _AtomicBroadcast_Broadcast_Handler, <i class="conum" data-value="2"></i><b>(2)</b>
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Deliver",
			Handler:       _AtomicBroadcast_Deliver_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "orderer/ab.proto",
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注册 server 的方法</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>指定 Broadcast 的消息由 _AtomicBroadcast_Broadcast_Handler 方法来处理</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>真正处理消息的是 被注册的 server 对象的 Broadcast 方法</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">/orderer/common/server/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Start(cmd string, conf *localconfig.TopLevel) {
	...
	ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server) <i class="conum" data-value="1"></i><b>(1)</b>
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注册了 server</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这里的 server</p>
</div>
<div class="listingblock">
<div class="title">/orderer/common/server/server.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type server struct { <i class="conum" data-value="1"></i><b>(1)</b>
	bh    *broadcast.Handler
	dh    *deliver.Handler
	debug *localconfig.Debug
	*multichannel.Registrar
}
...
func (s *server) Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error {
	logger.Debugf("Starting new Broadcast handler")
	defer func() {
		if r := recover(); r != nil {
			logger.Criticalf("Broadcast client triggered panic: %s\n%s", r, debug.Stack())
		}
		logger.Debugf("Closing Broadcast stream")
	}()
	return s.bh.Handle(&amp;broadcastMsgTracer{ <i class="conum" data-value="2"></i><b>(2)</b>
		AtomicBroadcast_BroadcastServer: srv,
		msgTracer: msgTracer{
			debug:    s.debug,
			function: "Broadcast",
		},
	})
}

// Deliver sends a stream of blocks to a client after ordering
func (s *server) Deliver(srv ab.AtomicBroadcast_DeliverServer) error {
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>server 实现了 AtomicBroadcastServer 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>实际处理 client 端发出的强求的方法</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Handle 方法</p>
</div>
<div class="listingblock">
<div class="title">/orderer/common/broadcast/broadcast.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func (bh *Handler) Handle(srv ab.AtomicBroadcast_BroadcastServer) error {
	...
	for {
		...
		resp := bh.ProcessMessage(msg, addr) <i class="conum" data-value="1"></i><b>(1)</b>
		...
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>处理消息</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="solo">solo</h3>
<div class="sect3">
<h4 id="处理消息的方法">处理消息的方法</h4>
<div class="listingblock">
<div class="title">/orderer/common/broadcast/broadcast.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func (bh *Handler) ProcessMessage(msg *cb.Envelope, addr string) (resp *ab.BroadcastResponse) {
	...
	if !isConfig {
		...
		err = processor.Order(msg, configSeq)
		...
	} else { // isConfig
		...
		err = processor.Configure(config, configSeq)
		...
	}
	...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="processor">processor</h4>
<div class="paragraph">
<p>processor 实际上是一个 Consenter 接口的实现</p>
</div>
<div class="listingblock">
<div class="title">/orderer/common/broadcast/broadcast.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type Consenter interface {
	Order(env *cb.Envelope, configSeq uint64) error
	Configure(config *cb.Envelope, configSeq uint64) error
	WaitReady() error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处实际工作的是 /orderer/consensus/solo/consensus.go 中的 chain</p>
</div>
<div class="listingblock">
<div class="title">/orderer/consensus/solo/consensus.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type chain struct { <i class="conum" data-value="1"></i><b>(1)</b>
	support  consensus.ConsenterSupport
	sendChan chan *message
	exitChan chan struct{}
}
...
func (ch *chain) WaitReady() error {
	return nil
}

func (ch *chain) Order(env *cb.Envelope, configSeq uint64) error {
	select {
	case ch.sendChan &lt;- &amp;message{ <i class="conum" data-value="2"></i><b>(2)</b>
		configSeq: configSeq,
		normalMsg: env,
	}:
		return nil
	case &lt;-ch.exitChan:
		return fmt.Errorf("Exiting")
	}
}

func (ch *chain) Configure(config *cb.Envelope, configSeq uint64) error {
	select {
	case ch.sendChan &lt;- &amp;message{ <i class="conum" data-value="3"></i><b>(3)</b>
		configSeq: configSeq,
		configMsg: config,
	}:
		return nil
	case &lt;-ch.exitChan:
		return fmt.Errorf("Exiting")
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>chain 实现了 Consenter 接口</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Order 方法内部向 sendChan 发消息</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Configure 方法内部向 sendChan 发消息</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>处理消息的是 main 方法</p>
</div>
<div class="listingblock">
<div class="title">/orderer/consensus/solo/consensus.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func (ch *chain) main() {
	...
	for {
		seq := ch.support.Sequence()
		err = nil
		select {
		case msg := &lt;-ch.sendChan: <i class="conum" data-value="1"></i><b>(1)</b>
			...
		case &lt;-timer:
			...
		case &lt;-ch.exitChan:
			...
		}
	}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>sendChan 收到消息时，处理</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="为什么使用的是_solo_呢">为什么使用的是 solo 呢</h4>
<div class="listingblock">
<div class="title">/orderer/common/server/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Start(cmd string, conf *localconfig.TopLevel) {
	...
	manager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback)
	...
}
...
func initializeMultichannelRegistrar(
	bootstrapBlock *cb.Block,
	ri *replicationInitiator,
	clusterDialer *cluster.PredicateDialer,
	srvConf comm.ServerConfig,
	srv *comm.GRPCServer,
	conf *localconfig.TopLevel,
	signer crypto.LocalSigner,
	metricsProvider metrics.Provider,
	healthChecker healthChecker,
	lf blockledger.Factory,
	callbacks ...channelconfig.BundleActor,
) *multichannel.Registrar {
	genesisBlock := extractBootstrapBlock(conf)
	...
	consenters := make(map[string]consensus.Consenter)

	registrar := multichannel.NewRegistrar(lf, signer, metricsProvider, callbacks...)

	consenters["solo"] = solo.New() <i class="conum" data-value="1"></i><b>(1)</b>
	var kafkaMetrics *kafka.Metrics
	consenters["kafka"], kafkaMetrics = kafka.New(conf.Kafka, metricsProvider, healthChecker) <i class="conum" data-value="2"></i><b>(2)</b>
	...
	registrar.Initialize(consenters)
	return registrar
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建 solo 共识器</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建 kafka 共识器</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">/orderer/common/multichannel/registrar.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func (r *Registrar) Initialize(consenters map[string]consensus.Consenter) {
	r.consenters = consenters
	existingChains := r.ledgerFactory.ChainIDs()

	for _, chainID := range existingChains {
		...
		if _, ok := ledgerResources.ConsortiumsConfig(); ok {
			...
			chain := newChainSupport( <i class="conum" data-value="1"></i><b>(1)</b>
				r,
				ledgerResources,
				r.consenters,
				r.signer,
				r.blockcutterMetrics,
			)
			...
		} else {
			...
		}

	}
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>调用 newChainSupport 方法</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">/orderer/common/multichannel/chainsupport.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func newChainSupport(
	registrar *Registrar,
	ledgerResources *ledgerResources,
	consenters map[string]consensus.Consenter,
	signer crypto.LocalSigner,
	blockcutterMetrics *blockcutter.Metrics,
) *ChainSupport {
	...
	consenterType := ledgerResources.SharedConfig().ConsensusType() <i class="conum" data-value="1"></i><b>(1)</b>
	consenter, ok := consenters[consenterType] <i class="conum" data-value="2"></i><b>(2)</b>
	...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>获取 共识器 类型，这里实际的值是 solo</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>根据 共识器 类型来决定使用哪种共识器</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="orderer_genesisblock">orderer genesisblock</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">/orderer/common/server/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func Start(cmd string, conf *localconfig.TopLevel) {
	bootstrapBlock := extractBootstrapBlock(conf) <i class="conum" data-value="1"></i><b>(1)</b>
    ...
	lf, _ := createLedgerFactory(conf, metricsProvider) <i class="conum" data-value="2"></i><b>(2)</b>
    ...
    manager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback) <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>读取创世块信息</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建账本文件夹</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建默认 channel</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="读取创世块信息">读取创世块信息</h3>
<div class="listingblock">
<div class="title">/orderer/common/server/main.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func extractBootstrapBlock(conf *localconfig.TopLevel) *cb.Block {
	var bootstrapBlock *cb.Block

	// Select the bootstrapping mechanism
	switch conf.General.GenesisMethod {
	case "provisional":
		bootstrapBlock = encoder.New(genesisconfig.Load(conf.General.GenesisProfile)).GenesisBlockForChannel(conf.General.SystemChannel)
	case "file":
		bootstrapBlock = file.New(conf.General.GenesisFile).GenesisBlock() <i class="conum" data-value="1"></i><b>(1)</b>
	default:
		logger.Panic("Unknown genesis method:", conf.General.GenesisMethod)
	}

	return bootstrapBlock
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>读取了配置项 <strong>General.GenesisFile</strong> 所指定的文件的内容</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="创建账本文件夹">创建账本文件夹</h3>
<div class="listingblock">
<div class="title">/orderer/common/server/util.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func createLedgerFactory(conf *config.TopLevel, metricsProvider metrics.Provider) (blockledger.Factory, string) {
	var lf blockledger.Factory
	var ld string
	switch conf.General.LedgerType {
	case "file":
		ld = conf.FileLedger.Location <i class="conum" data-value="1"></i><b>(1)</b>
        ...
        lf = fileledger.New(ld, metricsProvider) <i class="conum" data-value="2"></i><b>(2)</b>
        ...
		createSubDir(ld, fsblkstorage.ChainsDir) <i class="conum" data-value="3"></i><b>(3)</b>
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>读取了配置项 FileLedger.Location</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>按 FileLedger.Location 的值，创建了文件夹，并在其下创建了一个 leveldb 的数据库 <strong>index</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在 FileLedger.Location 下面创建了 channel 的父文件夹 <strong>chains</strong></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="创建默认_channel">创建默认 channel</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="缩写">缩写</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 缩写</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">缩写</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Membership service provider 会员服务提供者</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BCCSP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">blockchain（前两个字母BC） cryptographic service provider 区域链加密服务提供者</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ab</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic broadcast原子（操作）广播</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lscc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lifecycle(L) system(S) chaincode（CC）生命周期系统链码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specification，规格标准，详细说明</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">key-value 键-值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CDS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ChaincodeDeploymentSpec</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CIS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ChaincodeInvocationSpec</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mgmt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">management</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">software-based</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AtomicBroadcast</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">genesis block，创世纪的block，也就是区域链中的第一个块</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CC或cc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCC或scc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cscc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">configer system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lscc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lifecycle system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">escc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">endorser system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vscc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">validator system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qscc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">querier system chaincode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">alg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">algorithm 算法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mcs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mspMessageCryptoService</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mock</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假装，学样子，模仿的意思，基本上是服务于xxx_test.go的，即用于测试的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gossip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种使分布结点达到状态最终一致的算法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">attr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">attribute</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FsBlockStore</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">file system block store</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vdb</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">versioned database 也就是状态数据库</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RTEnv</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">runtime environment运行环境</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pkcs11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pcks#11，一种公匙加密标准，有一套叫做Cryptoki的接口，是一组平台设备无关的API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MCS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mspMessageCryptoService，消息加密服务</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SecurityAdvisor</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">impl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">implement，好多处XXX.go和XXXimpl.go是对应的，前者是用于接口或者定义的，后者是实现该接口或定义的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FSM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">finite state machine 有限状态机</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem 文件系统</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">blk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">block</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cli</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">command line interface 命令行界面</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CFG</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FABRIC_CFG_PATH中的，应该是config的意思</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mgr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">manager</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cpinfo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkpoint information，检查点信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DevMode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">development mode，开发模式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register，注册，登记</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hdr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">header</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">impl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">implement</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">oid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectIdentifier，对象标识符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ou或OU</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">organizational unit</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CRL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">certificate revocation list，废除证书列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">proposal，申请，交易所发送的申请</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ACL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access Control List，访问控制列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rwset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read/write set，读写集</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tx，Tx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">transaction，交易</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cryptographic service provider，BCCSP的后三个字母，加密服务提供者</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">opt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">option，选项</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">opts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">options，多个选项</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SKI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前证书标识，所谓标识，一般是对公匙进行一下hash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AKI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">签署方的SKI，也就是签署方的公匙标识</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hardware Security Modules</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">KeyStore，Key存储，这个key指的是用于签名的公匙私匙</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">oid</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OBJECT IDENTIFIER，对象身份标识</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
来源于网络，待整理确认
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="目录">目录</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. 目录</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bcssp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密服务代码目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">common</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全局公用代码目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">核心功能代码目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">docs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以.rst文件为核心，可编译生成文档。说明文档的目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">events</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件代码目录，用于生产和消费信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">examples</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">示例目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">gossip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本意是绯闻的意思，是一种可达到去中心化，有一定容错能力且可达到最终一致的传播算法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">msp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">会员服务代码目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">orderer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">就理解成orderer目录就好，orderer也算是区域链中的专用名词，用于消息的订阅与分发处理</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">protos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原型目录，定义个各种原型和生成的对应的XXX.pb.go源码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vendor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原意是商贩，在此就是存放go中使用的全部的各种第三方包</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
来源于网络，待整理确认
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="peer">peer</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/diag-974b9a9f3e1be66018ad964563319045.svg" alt="diag 974b9a9f3e1be66018ad964563319045" width="657" height="522">
</div>
<div class="title">Figure 7. peer 命令结构</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jww">jww</h2>
<div class="sectionbody">
<div class="paragraph">
<p>jww 全称 jwalterweatherman，源码在 <a href="https://github.com/spf13/jwalterweatherman">github</a></p>
</div>
<div class="sect2">
<h3 id="特点">特点</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>可同时进行 terminal 输出 和 日志记录</p>
</li>
<li>
<p>可分别进行级别控制</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="级别">级别</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>TRACE</p>
</li>
<li>
<p>DEBUG</p>
</li>
<li>
<p>INFO</p>
</li>
<li>
<p>WARN</p>
</li>
<li>
<p>ERROR</p>
</li>
<li>
<p>CRITICAL</p>
</li>
<li>
<p>FATAL</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">const (
	LevelTrace Threshold = iota
	LevelDebug
	LevelInfo
	LevelWarn
	LevelError
	LevelCritical
	LevelFatal
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过源码可以看到，级别是个枚举，其对应的数值由 0 至 6 逐渐增大。 默认情况下:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Trace, Debug, Info 对应的是 devNull，即被忽略</p>
</li>
<li>
<p>Warn 及以上，会被写入日志(如果提供了日志文件的话)</p>
</li>
<li>
<p>Error 及以上会被打印到 terminal</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>devNull 是什么?</p>
</div>
<div class="listingblock">
<div class="title">devNull 的部分代码</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">type devNull int

func (devNull) Write(p []byte) (int, error) {
	return len(p), nil
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从代码可以看出，devNull 是 io.Writer 的实现，其 Write 方法内部没有做任何 <strong>写</strong> 的操作，从而达到了 <strong>忽略</strong> 的效果</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="示例">示例</h3>
<div class="listingblock">
<div class="title">github.com/spf13/viper/util.go</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">func absPathify(inPath string) string {
	jww.INFO.Println("Trying to resolve absolute path to", inPath) <i class="conum" data-value="1"></i><b>(1)</b>

	if strings.HasPrefix(inPath, "$HOME") {
		inPath = userHomeDir() + inPath[5:]
	}

	if strings.HasPrefix(inPath, "$") {
		end := strings.Index(inPath, string(os.PathSeparator))
		inPath = os.Getenv(inPath[1:end]) + inPath[end:]
	}

	if filepath.IsAbs(inPath) {
		return filepath.Clean(inPath)
	}

	p, err := filepath.Abs(inPath)
	if err == nil {
		return filepath.Clean(p)
	} else {
		jww.ERROR.Println("Couldn't discover absolute path") <i class="conum" data-value="2"></i><b>(2)</b>
		jww.ERROR.Println(err) <i class="conum" data-value="3"></i><b>(3)</b>
	}
	return ""
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>INFO 级别</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ERROR 级别</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ERROR 级别</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="意义是什么">意义是什么?</h3>
<div class="paragraph">
<p>以 viper 这个库为例，如果不做级别设置，那么日志只记录 Warn 及以上级别的信息，terminal 只输出 Error 及以上级别的信息，换言之，是有了一定的错误的时候。但是如果我们代码中，在使用 viper 的时候，出现了问题，我们想知道更多细节，就可以打出更多级别的消息。比如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">jww.SetStdoutThreshold(jww.LevelTrace) <i class="conum" data-value="1"></i><b>(1)</b>
jww.SetLogThreshold(jww.LevelTrace) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置 terminal 输出级别为 Trace</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置 log 输出级别为 Trace</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这样，就可以打印出所有消息，<strong>按需输出</strong>，这种方式很灵活。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kingpin">kingpin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>kingpin 是命令行的参数，Flag 的 parser</p>
</div>
<div class="sect2">
<h3 id="示例_1">示例 1</h3>
<div class="listingblock">
<div class="title">源码 1</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">package main

import (
    "fmt"

    "gopkg.in/alecthomas/kingpin.v2"
)

var (
    debug   = kingpin.Flag("debug", "Enable debug mode.").Bool()
    timeout = kingpin.Flag("timeout", "Timeout waiting for ping.").Default("5s").OverrideDefaultFromEnvar("PING_TIMEOUT").Short('t').Duration()
    ip      = kingpin.Arg("ip", "IP address to ping.").Required().IP()
    count   = kingpin.Arg("count", "Number of packets to send").Int()
)

func main() {
    kingpin.Version("0.0.1")
    kingpin.Parse()
    fmt.Printf("Would ping: %s with timeout %s and count %d\n", *ip, *timeout, *count)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">效果 1</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">$ ping --help
usage: ping [&lt;flags&gt;] &lt;ip&gt; [&lt;count&gt;]

Flags:
  --debug            Enable debug mode.
  --help             Show help.
  -t, --timeout=5s   Timeout waiting for ping.

Args:
  &lt;ip&gt;        IP address to ping.
  [&lt;count&gt;]   Number of packets to send
$ ping 1.2.3.4 5
Would ping: 1.2.3.4 with timeout 5s and count 5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="示例_2">示例 2</h3>
<div class="listingblock">
<div class="title">源码 2</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="go">package main

import (
    "os"
    "strings"
    "gopkg.in/alecthomas/kingpin.v2"
)

var (
    app      = kingpin.New("chat", "A command-line chat application.")
    debug    = app.Flag("debug", "Enable debug mode.").Bool()
    serverIP = app.Flag("server", "Server address.").Default("127.0.0.1").IP()

    register     = app.Command("register", "Register a new user.")
    registerNick = register.Arg("nick", "Nickname for user.").Required().String()
    registerName = register.Arg("name", "Name of user.").Required().String()

    post        = app.Command("post", "Post a message to a channel.")
    postImage   = post.Flag("image", "Image to post.").File()
    postChannel = post.Arg("channel", "Channel to post to.").Required().String()
    postText    = post.Arg("text", "Text to post.").Strings()
)

func main() {
    switch kingpin.MustParse(app.Parse(os.Args[1:])) {
    // Register user
    case register.FullCommand():
        println(*registerNick)

    // Post message
    case post.FullCommand():
        if *postImage != nil {
        }
        text := strings.Join(*postText, " ")
        println("Post:", text)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">效果 2</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="bash">$ chat --help
usage: chat [&lt;flags&gt;] &lt;command&gt; [&lt;flags&gt;] [&lt;args&gt; ...]

A command-line chat application.

Flags:
  --help              Show help.
  --debug             Enable debug mode.
  --server=127.0.0.1  Server address.

Commands:
  help [&lt;command&gt;]
    Show help for a command.

  register &lt;nick&gt; &lt;name&gt;
    Register a new user.

  post [&lt;flags&gt;] &lt;channel&gt; [&lt;text&gt;]
    Post a message to a channel.

$ chat help post
usage: chat [&lt;flags&gt;] post [&lt;flags&gt;] &lt;channel&gt; [&lt;text&gt;]

Post a message to a channel.

Flags:
  --image=IMAGE  Image to post.

Args:
  &lt;channel&gt;  Channel to post to.
  [&lt;text&gt;]   Text to post.

$ chat post --image=~/Downloads/owls.jpg pics
...</code></pre>
</div>
</div>
</div>
</div>
</div>
                            </div>
                            <div id="search_result_container" class="page-inner">
                                <ul id="search-results"></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- End Main Content -->

        <!-- End Main Content and Sidebar -->

        <!-- Footer -->

        <script src="/js/vendor/jquery.js"></script>
        <script src="/js/foundation.min.js"></script>
        <script src="/js/vendor/modernizr.js"></script>
        <script src="/js/toc.js"></script>

        <script src="/js/search/lunr.min.js"></script>
        <script src="/js/search/lunr.stemmer.support.js"></script>
        <script src="/js/search/tinyseg.js"></script>
        <script src="/js/search/lunr.ja.js"></script>
        <script src="/js/search/search.js"></script>
        <script>
            $(document).foundation();
            var doc = document.documentElement;
            doc.setAttribute("data-useragent", navigator.userAgent);

            var host = window.location.host;
            var wholeHref = window.location.href;

            var href = wholeHref
                .replace("https://", "")
                .replace("http://", "")
                .replace(host, "");

            var list = $(".post > li > a");
            list.each(function() {
                if ($(this).attr("href") === href) {
                    $(this).addClass("active");
                    return false;
                }
            });

            $(".btn.pull-left").click(function() {
                var $post = $(".post");
                if ($post.hasClass("with-summary")) {
                    $(".post-summary").animate({ left: "-300px" }, "slow");
                    $(".post-body").animate({ left: 0 }, "slow", function() {
                        $post.removeClass("with-summary");
                    });
                    $(".page-header").animate({left:0}, "slow")
                } else {
                    $(".post-summary").animate({ left: 0 }, "slow");
                    $(".post-body").animate({ left: "300px" }, "slow");
                    $post.addClass("with-summary");
                    $(".page-header").animate({left: "300px"}, "slow")
                }
            });

            window.store = {
                
                    "allposts-all-cap": {
                        "title": "",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto",
                        "url": "/allposts/all/cap"
                    }
                    ,
                
                    "allposts-debug-orderer-genesisblock": {
                        "title": "orderer genesisblock",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: orderer-genesisblock// :toc: true// :toclevels: 4:page-navtitle: orderer genesisblock:chapter: 2:section: 3:page-section: {section}== orderer genesisblock./orderer/common/server/main.go[source,go]----func Start(cmd string, conf *localconfig.TopLevel) {\tbootstrapBlock := extractBootstrapBlock(conf) //     ...\tlf, _ := createLedgerFactory(conf, metricsProvider) //     ...    manager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback) // }---- 读取创世块信息 创建账本文件夹 创建默认 channel=== 读取创世块信息./orderer/common/server/main.go[source,go]----func extractBootstrapBlock(conf *localconfig.TopLevel) *cb.Block {\tvar bootstrapBlock *cb.Block\t// Select the bootstrapping mechanism\tswitch conf.General.GenesisMethod {\tcase \"provisional\":\t\tbootstrapBlock = encoder.New(genesisconfig.Load(conf.General.GenesisProfile)).GenesisBlockForChannel(conf.General.SystemChannel)\tcase \"file\":\t\tbootstrapBlock = file.New(conf.General.GenesisFile).GenesisBlock() // \tdefault:\t\tlogger.Panic(\"Unknown genesis method:\", conf.General.GenesisMethod)\t}\treturn bootstrapBlock}---- 读取了配置项 *General.GenesisFile* 所指定的文件的内容=== 创建账本文件夹./orderer/common/server/util.go[source,go]----func createLedgerFactory(conf *config.TopLevel, metricsProvider metrics.Provider) (blockledger.Factory, string) {\tvar lf blockledger.Factory\tvar ld string\tswitch conf.General.LedgerType {\tcase \"file\":\t\tld = conf.FileLedger.Location //         ...        lf = fileledger.New(ld, metricsProvider) //         ...\t\tcreateSubDir(ld, fsblkstorage.ChainsDir) //     ...}---- 读取了配置项 FileLedger.Location 按 FileLedger.Location 的值，创建了文件夹，并在其下创建了一个 leveldb 的数据库 *index* 在 FileLedger.Location 下面创建了 channel 的父文件夹 *chains*=== 创建默认 channel",
                        "url": "/allposts/debug/orderer-genesisblock"
                    }
                    ,
                
                    "allposts-debug-create-channel": {
                        "title": "create channel",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: create channel:page-navtitle: create channel:chapter: 2:section: 4:page-section: {section}== create channel=== 命令 peer channel create命令如下[source,bash]----peer channel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050 ----TIP: channel 是 peer 的子命令，create 是 channel 的子命令create channel 是 peer 节点执行的命令，入口处在 /peer/main.go./peer/main.go[source,go]----func main() {\t...\tmainCmd.AddCommand(channel.Cmd(nil)) // \t...}---- 为 mainCmd 添加了 channel 子命令 [TIP]====mainCmd 就是 *peer*[source,go]----var mainCmd = &cobra.Command{\tUse: \"peer\"}----====channel 里面什么样呢./peer/channel/channel.go[source,go]----func Cmd(cf *ChannelCmdFactory) *cobra.Command {\t...\tchannelCmd.AddCommand(createCmd(cf)) // \t...}---- 添加了 *create* 子命令createCmd 里面./peer/channel/create.go[source,go]----func createCmd(cf *ChannelCmdFactory) *cobra.Command {\tcreateCmd := &cobra.Command{\t\tUse:   \"create\",\t\tShort: \"Create a channel\",\t\tLong:  \"Create a channel and write the genesis block to a file.\",\t\tRunE: func(cmd *cobra.Command, args []string) error {\t\t\treturn create(cmd, args, cf) // \t\t},\t}\tflagList := []string{\t\t\"channelID\",\t\t\"file\",\t\t\"outputBlock\",\t\t\"timeout\",\t}\tattachFlags(createCmd, flagList)\treturn createCmd}---- create channel 实际执行的是 *create* 方法./peer/channel/create.go[source,go]----func create(cmd *cobra.Command, args []string, cf *ChannelCmdFactory) error {\t...\tif cf == nil {\t\tcf, err = InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererRequired) // \t\t...\t}\treturn executeCreate(cf)}---- 创建了一个 *ChannelCmdFactory* 对象看一下 *ChannelCmdFactory* 结构 ./peer/channel/channel.go[source,go]----type ChannelCmdFactory struct {\tEndorserClient   pb.EndorserClient\tSigner           msp.SigningIdentity\tBroadcastClient  common.BroadcastClient // \tDeliverClient    deliverClientIntf\tBroadcastFactory BroadcastClientFactory // }---- BroadcastClient 用来通信 BroadcastFactory 是一个方法，用来得到 BroadcastClient 对象./peer/common/broadcastclient.go[source,go]----type BroadcastClient interface { // \tSend(env *cb.Envelope) error\tClose() error}type broadcastClient struct { // \tclient ab.AtomicBroadcast_BroadcastClient // }...func (s *broadcastClient) Send(env *cb.Envelope) error {\t...}func (s *broadcastClient) Close() error {\t...}---- BroadcastClient 接口 broadcastClient 实现了 BroadcastClient 接口 真正完成 Send, Close 动作的是 ab.AtomicBroadcast_BroadcastClient=== gRPC 的使用==== AtomicBroadcast/protos/orderer/ab.proto 文件定义了 AtomicBroadcast 的原型.protos/orderer/ab.proto[source,pb]----...service AtomicBroadcast {    rpc Broadcast(stream common.Envelope) returns (stream BroadcastResponse) {}    rpc Deliver(stream common.Envelope) returns (stream DeliverResponse) {}}----==== AtomicBroadcastClient/protos/orderer/ab.proto 经过 gPRC 编译后得到 /protos/orderer/ab.pb.go，里面包括 2 个部分  *AtomicBroadcastClient*，*AtomicBroadcastServer*，这里先看 *AtomicBroadcastClient*./protos/orderer/ab.pb.go[source,go]----type AtomicBroadcastClient interface { // \tBroadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error)\tDeliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error)}type atomicBroadcastClient struct { // \tcc *grpc.ClientConn}func NewAtomicBroadcastClient(cc *grpc.ClientConn) AtomicBroadcastClient { // \treturn &atomicBroadcastClient{cc}}func (c *atomicBroadcastClient) Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error) {\t...}type AtomicBroadcast_BroadcastClient interface { // \tSend(*common.Envelope) error\tRecv() (*BroadcastResponse, error)\tgrpc.ClientStream}type atomicBroadcastBroadcastClient struct { // \tgrpc.ClientStream}func (x *atomicBroadcastBroadcastClient) Send(m *common.Envelope) error {\t...}func (x *atomicBroadcastBroadcastClient) Recv() (*BroadcastResponse, error) {\t...}---- AtomicBroadcastClient 接口 atomicBroadcastClient 实现了 AtomicBroadcastClient 接口 创建一个 atomicBroadcastClient 实例 AtomicBroadcast_BroadcastClient 接口是针对 AtomicBroadcastClient 中的 Broadcast 动作的客户端 atomicBroadcastBroadcastClient 实现了 AtomicBroadcast_BroadcastClient 接口NOTE: AtomicBroadcast_DeliverClient 也是有的，与 AtomicBroadcast_BroadcastClient 类似，不再缀述 ==== OrdererClient./peer/common/ordererclient.go[source,go]----type OrdererClient struct { // \tcommonClient}func NewOrdererClientFromEnv() (*OrdererClient, error) { // \taddress, override, clientConfig, err := configFromEnv(\"orderer\") // \t...}func (oc *OrdererClient) Broadcast() (ab.AtomicBroadcast_BroadcastClient, error) {\t...}func (oc *OrdererClient) Deliver() (ab.AtomicBroadcast_DeliverClient, error) {\t...}---- OrdererClient 实现了 AtomicBroadcastClient 接口 NewOrdererClientFromEnv 创建了一 OrdererClient 实例 获取了关于 orderer 的配置，如地址，超时时间等前面提到过 InitCmdFactory 方法./peer/chaincode/common.go[source,go]----func InitCmdFactory(cmdName string, isEndorserRequired, isOrdererRequired bool) (*ChaincodeCmdFactory, error) {\t...\tif isOrdererRequired {\t\t...\t\tbroadcastClient, err = common.GetBroadcastClientFnc()\t\t...\t}\t...}----./peer/chaincode/common.go[source,go]----func init() {\t...\tGetBroadcastClientFnc = GetBroadcastClient\t...}----./peer/common/broadcastclient.go[source,go]----func GetBroadcastClient() (BroadcastClient, error) {\toc, err := NewOrdererClientFromEnv() // \t...}---- 调用了 OrdererClient 中的 NewOrdererClientFromEnv 方法==== 消息的发出.peer/channel/create.go[source,go]----func sendCreateChainTransaction(cf *ChannelCmdFactory) error {\t...\tdefer broadcastClient.Close()\terr = broadcastClient.Send(chCrtEnv) // \treturn err}---- broadcastClient.Send 方法实际上调用了 gRPC，从 peer 节点发送消息给了 orderer 服务==== AtomicBroadcastServer./protos/orderer/ab.pb.go[source,go]----type AtomicBroadcastServer interface {\tBroadcast(AtomicBroadcast_BroadcastServer) error\tDeliver(AtomicBroadcast_DeliverServer) error}func RegisterAtomicBroadcastServer(s *grpc.Server, srv AtomicBroadcastServer) { // \ts.RegisterService(&_AtomicBroadcast_serviceDesc, srv)}func _AtomicBroadcast_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {\treturn srv.(AtomicBroadcastServer).Broadcast(&atomicBroadcastBroadcastServer{stream}) // }...var _AtomicBroadcast_serviceDesc = grpc.ServiceDesc{\tServiceName: \"orderer.AtomicBroadcast\",\tHandlerType: (*AtomicBroadcastServer)(nil),\tMethods:     []grpc.MethodDesc{},\tStreams: []grpc.StreamDesc{\t\t{\t\t\tStreamName:    \"Broadcast\",\t\t\tHandler:       _AtomicBroadcast_Broadcast_Handler, \t\t\tServerStreams: true,\t\t\tClientStreams: true,\t\t},\t\t{\t\t\tStreamName:    \"Deliver\",\t\t\tHandler:       _AtomicBroadcast_Deliver_Handler,\t\t\tServerStreams: true,\t\t\tClientStreams: true,\t\t},\t},\tMetadata: \"orderer/ab.proto\",}---- 注册 server 的方法 指定 Broadcast 的消息由 _AtomicBroadcast_Broadcast_Handler 方法来处理 真正处理消息的是 被注册的 server 对象的 Broadcast 方法./orderer/common/server/main.go[source,go]----func Start(cmd string, conf *localconfig.TopLevel) {\t...\tab.RegisterAtomicBroadcastServer(grpcServer.Server(), server) // \t...}---- 注册了 server这里的 server ./orderer/common/server/server.go[source,go]----type server struct { // \tbh    *broadcast.Handler\tdh    *deliver.Handler\tdebug *localconfig.Debug\t*multichannel.Registrar}...func (s *server) Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error {\tlogger.Debugf(\"Starting new Broadcast handler\")\tdefer func() {\t\tif r := recover(); r != nil {\t\t\tlogger.Criticalf(\"Broadcast client triggered panic: %s\\n%s\", r, debug.Stack())\t\t}\t\tlogger.Debugf(\"Closing Broadcast stream\")\t}()\treturn s.bh.Handle(&broadcastMsgTracer{ // \t\tAtomicBroadcast_BroadcastServer: srv,\t\tmsgTracer: msgTracer{\t\t\tdebug:    s.debug,\t\t\tfunction: \"Broadcast\",\t\t},\t})}// Deliver sends a stream of blocks to a client after orderingfunc (s *server) Deliver(srv ab.AtomicBroadcast_DeliverServer) error {\t...}---- server 实现了 AtomicBroadcastServer 接口 实际处理 client 端发出的强求的方法Handle 方法./orderer/common/broadcast/broadcast.go[source,go]----func (bh *Handler) Handle(srv ab.AtomicBroadcast_BroadcastServer) error {\t...\tfor {\t\t...\t\tresp := bh.ProcessMessage(msg, addr) // \t\t...\t}}---- 处理消息=== solo ==== 处理消息的方法./orderer/common/broadcast/broadcast.go[source,go]----func (bh *Handler) ProcessMessage(msg *cb.Envelope, addr string) (resp *ab.BroadcastResponse) {\t...\tif !isConfig {\t\t...\t\terr = processor.Order(msg, configSeq)\t\t...\t} else { // isConfig\t\t...\t\terr = processor.Configure(config, configSeq)\t\t...\t}\t...}----==== processorprocessor 实际上是一个 Consenter 接口的实现./orderer/common/broadcast/broadcast.go[source,go]----type Consenter interface {\tOrder(env *cb.Envelope, configSeq uint64) error\tConfigure(config *cb.Envelope, configSeq uint64) error\tWaitReady() error}----此处实际工作的是 /orderer/consensus/solo/consensus.go 中的 chain./orderer/consensus/solo/consensus.go[source,go]----type chain struct { // \tsupport  consensus.ConsenterSupport\tsendChan chan *message\texitChan chan struct{}}...func (ch *chain) WaitReady() error {\treturn nil}func (ch *chain) Order(env *cb.Envelope, configSeq uint64) error {\tselect {\tcase ch.sendChan \t\tconfigSeq: configSeq,\t\tnormalMsg: env,\t}:\t\treturn nil\tcase \t\tconfigSeq: configSeq,\t\tconfigMsg: config,\t}:\t\treturn nil\tcase  chain 实现了 Consenter 接口 Order 方法内部向 sendChan 发消息 Configure 方法内部向 sendChan 发消息处理消息的是 main 方法./orderer/consensus/solo/consensus.go[source,go]----func (ch *chain) main() {\t...\tfor {\t\tseq := ch.support.Sequence()\t\terr = nil\t\tselect {\t\tcase msg := \t\t\t...\t\tcase  sendChan 收到消息时，处理==== 为什么使用的是 solo 呢./orderer/common/server/main.go[source,go]----func Start(cmd string, conf *localconfig.TopLevel) {\t...\tmanager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback)\t...}...func initializeMultichannelRegistrar(\tbootstrapBlock *cb.Block,\tri *replicationInitiator,\tclusterDialer *cluster.PredicateDialer,\tsrvConf comm.ServerConfig,\tsrv *comm.GRPCServer,\tconf *localconfig.TopLevel,\tsigner crypto.LocalSigner,\tmetricsProvider metrics.Provider,\thealthChecker healthChecker,\tlf blockledger.Factory,\tcallbacks ...channelconfig.BundleActor,) *multichannel.Registrar {\tgenesisBlock := extractBootstrapBlock(conf)\t...\tconsenters := make(map[string]consensus.Consenter)\tregistrar := multichannel.NewRegistrar(lf, signer, metricsProvider, callbacks...)\tconsenters[\"solo\"] = solo.New() // \tvar kafkaMetrics *kafka.Metrics\tconsenters[\"kafka\"], kafkaMetrics = kafka.New(conf.Kafka, metricsProvider, healthChecker) // \t...\tregistrar.Initialize(consenters)\treturn registrar}---- 创建 solo 共识器 创建 kafka 共识器./orderer/common/multichannel/registrar.go[source,go]----func (r *Registrar) Initialize(consenters map[string]consensus.Consenter) {\tr.consenters = consenters\texistingChains := r.ledgerFactory.ChainIDs()\tfor _, chainID := range existingChains {\t\t...\t\tif _, ok := ledgerResources.ConsortiumsConfig(); ok {\t\t\t...\t\t\tchain := newChainSupport( // \t\t\t\tr,\t\t\t\tledgerResources,\t\t\t\tr.consenters,\t\t\t\tr.signer,\t\t\t\tr.blockcutterMetrics,\t\t\t)\t\t\t...\t\t} else {\t\t\t...\t\t}\t}\t...}---- 调用 newChainSupport 方法./orderer/common/multichannel/chainsupport.go[source,go]----func newChainSupport(\tregistrar *Registrar,\tledgerResources *ledgerResources,\tconsenters map[string]consensus.Consenter,\tsigner crypto.LocalSigner,\tblockcutterMetrics *blockcutter.Metrics,) *ChainSupport {\t...\tconsenterType := ledgerResources.SharedConfig().ConsensusType() // \tconsenter, ok := consenters[consenterType] // \t...}---- 获取 共识器 类型，这里实际的值是 solo 根据 共识器 类型来决定使用哪种共识器",
                        "url": "/allposts/debug/create-channel"
                    }
                    ,
                
                    "allposts-source-orderer": {
                        "title": "orderer",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: orderer:page-navtitle: orderer:chapter: 3:section: 4:page-section: {section}== ordererorderer 的入口在于 /orderer/main.go",
                        "url": "/allposts/source/orderer"
                    }
                    ,
                
                    "allposts-debug-orderer-config": {
                        "title": "orderder 配置",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: orderer-config// :toc: true// :toclevels: 4:page-navtitle: orderder 配置:chapter: 2:section: 2:page-section: {section}== orderer 配置orderer 启动时，从 /orderer/main.go 入口./orderer/main.go[source,go]----func main() {\tserver.Main()}----调用的是 ./orderer/common/server/main.go./orderer/common/server/main.go[source,go]----func Main() {\tfullCmd := kingpin.MustParse(app.Parse(os.Args[1:]))\t// \"version\" command\tif fullCmd == version.FullCommand() {\t\tfmt.Println(metadata.GetVersionInfo())\t\treturn\t}\tconf, err := localconfig.Load() // \tif err != nil {\t\tlogger.Error(\"failed to parse config: \", err)\t\tos.Exit(1)\t}\tinitializeLogging()\tinitializeLocalMsp(conf)\tprettyPrintStruct(conf)\tStart(fullCmd, conf)}---- 加载配置=== 加载配置./orderer/common/localconfig/config.go[source,go]----func Load() (*TopLevel, error) {\tconfig := viper.New()\tcoreconfig.InitViper(config, \"orderer\") // \tconfig.SetEnvPrefix(Prefix) // \tconfig.AutomaticEnv() // \treplacer := strings.NewReplacer(\".\", \"_\")\tconfig.SetEnvKeyReplacer(replacer)\tif err := config.ReadInConfig(); err != nil {\t\treturn nil, fmt.Errorf(\"Error reading configuration: %s\", err)\t}\tvar uconf TopLevel\tif err := viperutil.EnhancedExactUnmarshal(config, &uconf); err != nil {\t\treturn nil, fmt.Errorf(\"Error unmarshaling config into struct: %s\", err)\t}\tuconf.completeInitialization(filepath.Dir(config.ConfigFileUsed()))\treturn &uconf, nil}---- 初始化一个 viper 实例，制定配置文件名字为 orderer 设置环境变量前缀，这里前缀是 *ORDERER* 自动读取 *环境变量*==== 配置文件与环境变量的关系简单的说，*环境变量会覆盖配置文件中的配置项*，这样可以在不改变配置文件的前提下，做某些调整，非常方便，下面看下具体过程。进入 coreconfig.InitViper 内部 ./core/config/config.go[source,go]----func InitViper(v *viper.Viper, configName string) error {\tvar altPath = os.Getenv(\"FABRIC_CFG_PATH\") // \tif altPath != \"\" {\t\t// If the user has overridden the path with an envvar, its the only path\t\t// we will consider\t\tif !dirExists(altPath) {\t\t\treturn fmt.Errorf(\"FABRIC_CFG_PATH %s does not exist\", altPath)\t\t}\t\tAddConfigPath(v, altPath)\t} else {\t\t// If we get here, we should use the default paths in priority order:\t\t//\t\t// *) CWD\t\t// *) /etc/hyperledger/fabric\t\t// CWD\t\tAddConfigPath(v, \"./\")\t\t// And finally, the official path\t\tif dirExists(OfficialPath) {\t\t\tAddConfigPath(v, OfficialPath)\t\t}\t}\t// Now set the configuration file.\tif v != nil {\t\tv.SetConfigName(configName)\t} else {\t\tviper.SetConfigName(configName)\t}\treturn nil}---- 获取环境变量 *FABRIC_CFG_PATH* 的值*FABRIC_CFG_PATH* 指定了配置文件所在的位置，若未指定，则为当前文件夹[TIP]====viper 支持的配置文件扩展名有 7 种.github.com/spf13/viper/viper.go[source,go]----// Universally supported extensions.var SupportedExts []string = []string{\"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\"}----====orderer 读取的是 *orderer.yaml*，以 *GenesisMethod* 为例，来看一下配置文件和环境变量的关系配置文件中 GenesisMethod 的值是 provisional.orderer.yaml[source,yaml]----General:\t...\tGenesisMethod: provisional\t...----环境变量配置中 GenesisMethod 的值是 file.环境变量配置[source,bash]----ORDERER_GENERAL_GENESISMETHOD=file----TIP: 环境变量命名规则 *前缀_项_子项_以此类推，大写*，orderer 配置文件的前缀是 orderer，General 的子项 GenesisMethod 按照规则来，就是 ORDERER_GENERAL_GENESISMETHODfabric 会先读取配置文件的内容，然后在环境变量中找相应的配置项，如果存在，环境变量会覆盖掉配置文件中的项环境变量覆盖配置文件项的位置.github.com/spf13/viper/viper.go[source,go]----func (v *Viper) find(key string) interface{} {\t...\tif v.automaticEnvApplied { // \t\t// even if it hasn't been registered, if automaticEnv is used,\t\t// check any Get request\t\tif val = v.getEnv(v.mergeWithEnvPrefix(key)); val != \"\" {\t\t\tjww.TRACE.Println(key, \"found in environment with val:\", val)\t\t\treturn val\t\t}\t}\t...}---- v.automaticEnvApplied 在方法 config.AutomaticEnv() 中被设置为 true",
                        "url": "/allposts/debug/orderer-config"
                    }
                    ,
                
                    "allposts-third-lib-kingpin": {
                        "title": "kingpin",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: kingpin:toc: true:toclevels: 4:page-navtitle: kingpin:chapter: 4:section: 2:page-section: {section}== kingpinkingpin 是命令行的参数，Flag 的 parser=== 示例 1.源码 1[source,go]----package mainimport (    \"fmt\"    \"gopkg.in/alecthomas/kingpin.v2\")var (    debug   = kingpin.Flag(\"debug\", \"Enable debug mode.\").Bool()    timeout = kingpin.Flag(\"timeout\", \"Timeout waiting for ping.\").Default(\"5s\").OverrideDefaultFromEnvar(\"PING_TIMEOUT\").Short('t').Duration()    ip      = kingpin.Arg(\"ip\", \"IP address to ping.\").Required().IP()    count   = kingpin.Arg(\"count\", \"Number of packets to send\").Int())func main() {    kingpin.Version(\"0.0.1\")    kingpin.Parse()    fmt.Printf(\"Would ping: %s with timeout %s and count %d\\n\", *ip, *timeout, *count)}----.效果 1[source,bash]----$ ping --helpusage: ping []  []Flags:  --debug            Enable debug mode.  --help             Show help.  -t, --timeout=5s   Timeout waiting for ping.Args:          IP address to ping.  []   Number of packets to send$ ping 1.2.3.4 5Would ping: 1.2.3.4 with timeout 5s and count 5----=== 示例 2.源码 2[source,go][source,go]----package mainimport (    \"os\"    \"strings\"    \"gopkg.in/alecthomas/kingpin.v2\")var (    app      = kingpin.New(\"chat\", \"A command-line chat application.\")    debug    = app.Flag(\"debug\", \"Enable debug mode.\").Bool()    serverIP = app.Flag(\"server\", \"Server address.\").Default(\"127.0.0.1\").IP()    register     = app.Command(\"register\", \"Register a new user.\")    registerNick = register.Arg(\"nick\", \"Nickname for user.\").Required().String()    registerName = register.Arg(\"name\", \"Name of user.\").Required().String()    post        = app.Command(\"post\", \"Post a message to a channel.\")    postImage   = post.Flag(\"image\", \"Image to post.\").File()    postChannel = post.Arg(\"channel\", \"Channel to post to.\").Required().String()    postText    = post.Arg(\"text\", \"Text to post.\").Strings())func main() {    switch kingpin.MustParse(app.Parse(os.Args[1:])) {    // Register user    case register.FullCommand():        println(*registerNick)    // Post message    case post.FullCommand():        if *postImage != nil {        }        text := strings.Join(*postText, \" \")        println(\"Post:\", text)    }}----.效果 2[source,bash]----$ chat --helpusage: chat []  [] [ ...]A command-line chat application.Flags:  --help              Show help.  --debug             Enable debug mode.  --server=127.0.0.1  Server address.Commands:  help []    Show help for a command.  register      Register a new user.  post []  []    Post a message to a channel.$ chat help postusage: chat [] post []  []Post a message to a channel.Flags:  --image=IMAGE  Image to post.Args:    Channel to post to.  []   Text to post.$ chat post --image=~/Downloads/owls.jpg pics...----",
                        "url": "/allposts/third-lib/kingpin"
                    }
                    ,
                
                    "allposts-third-lib-jww": {
                        "title": "jww",
                        "author": "",
                        "category": "",
                        "content": ":page-layout: _auto:title: jww:toc: true:page-navtitle: jww:chapter: 4:section: 1:page-section: {section}== jwwjww 全称 jwalterweatherman，源码在 https://github.com/spf13/jwalterweatherman[github]=== 特点. 可同时进行 terminal 输出 和 日志记录. 可分别进行级别控制=== 级别. TRACE. DEBUG. INFO. WARN. ERROR. CRITICAL. FATAL[source,go,indent=0]----const (\tLevelTrace Threshold = iota\tLevelDebug\tLevelInfo\tLevelWarn\tLevelError\tLevelCritical\tLevelFatal)----通过源码可以看到，级别是个枚举，其对应的数值由 0 至 6 逐渐增大。 默认情况下:. Trace, Debug, Info 对应的是 devNull，即被忽略. Warn 及以上，会被写入日志(如果提供了日志文件的话). Error 及以上会被打印到 terminal[TIP]====devNull 是什么?.devNull 的部分代码[source,go]----type devNull intfunc (devNull) Write(p []byte) (int, error) {\treturn len(p), nil}----从代码可以看出，devNull 是 io.Writer 的实现，其 Write 方法内部没有做任何 *写* 的操作，从而达到了 *忽略* 的效果======= 示例.github.com/spf13/viper/util.go[source,go,]----func absPathify(inPath string) string {\tjww.INFO.Println(\"Trying to resolve absolute path to\", inPath) // \tif strings.HasPrefix(inPath, \"$HOME\") {\t\tinPath = userHomeDir() + inPath[5:]\t}\tif strings.HasPrefix(inPath, \"$\") {\t\tend := strings.Index(inPath, string(os.PathSeparator))\t\tinPath = os.Getenv(inPath[1:end]) + inPath[end:]\t}\tif filepath.IsAbs(inPath) {\t\treturn filepath.Clean(inPath)\t}\tp, err := filepath.Abs(inPath)\tif err == nil {\t\treturn filepath.Clean(p)\t} else {\t\tjww.ERROR.Println(\"Couldn't discover absolute path\") // \t\tjww.ERROR.Println(err) \t}\treturn \"\"}---- INFO 级别 ERROR 级别 ERROR 级别=== 意义是什么?以 viper 这个库为例，如果\b不做级别设置，那么日志只记录 Warn 及以上级别的信息，terminal 只输出 Error 及以上级别的信息，换言之，是有了一定的错误的时候。但是如果我们代码中，在使用 viper 的时候，出现了问题，我们想知道更多细节，就可以打出更多级别的消息。比如:[source,go]----jww.SetStdoutThreshold(jww.LevelTrace) // jww.SetLogThreshold(jww.LevelTrace) // ---- 设置 terminal 输出级别为 Trace 设置 log 输出级别为 Trace这样，就可以打印出所有消息，*按需输出*，这种方式很灵活。",
                        "url": "/allposts/third-lib/jww"
                    }
                    ,
                
                    "allposts-all-head": {
                        "title": "",
                        "author": "Liuhuiyu",
                        "category": "",
                        "content": ":page-layout: _auto= fabric 学习笔记Liuhuiyu ",
                        "url": "/allposts/all/head"
                    }
                    ,
                
                    "allposts-all-all": {
                        "title": "",
                        "author": "Liuhuiyu",
                        "category": "",
                        "content": "Table of Contents工作流程概览准备工作步骤调试准备第 1 步第 2 步第 3 步第 4 步调试 orderer调试 peer start调试 create channel调试 join channel调试 install chaincodeorderer 配置加载配置配置文件与环境变量的关系create channel命令 peer channel creategRPC 的使用AtomicBroadcastAtomicBroadcastClientOrdererClient消息的发出AtomicBroadcastServersolo处理消息的方法processor为什么使用的是 solo 呢orderer genesisblock读取创世块信息创建账本文件夹创建默认 channel缩写目录peerjww特点级别示例意义是什么?kingpin示例 1示例 2工作流程Figure 1. 交易流程时序图交易流程(1)客户端通过 SDK 接口向 背书节点 发送交易信息(2)每个 背书节点 模拟处理交易，并不会把交易信息写入账本。背书节点 会验证交易的合法性，并对交易签名，返回给 client。此时没有完成全网共识，各个 client 的交易顺序没有确定，可能存在 双花 问题，还不算是 \"有效的交易\"。(3)client 将签名后的交易发送给 order servic 集群进行交易排序和打包。order servic 集群通过共识算法对交易进行排序，打包成区块。(4)order servic 将打包后的区块广播发送给 提交节点，由其做最后的验证，并写入链。order servic 在发给 提交节点 的同时，是否也发给了 背书节点 ? 待确认概览准备工作fabric 源码，fabric-samples 源码GoLand (golang IDE)步骤用 GoLand 打开 fabric 源码新建 dev-network 目录把 sampleconfig 下的所有文件复制到 dev-network修改 core.yaml 中 fileSystemPath = fabric源码目录下dev-network/production/peer(绝对路径)修改 orderer.yaml 中 Location = fabric源码目录下dev-network/production/orderer(绝对路径)在 dev-network 新建 config，并复制 fabric-samples 模块 chaincode-docker-devmode下的 myc.tx 和 orderer.block调试准备第 1 步点击菜单项 Run/Edit ConfigurationsFigure 2. 点击菜单项 Run/Edit Configurations第 2 步点击弹出窗口左上交的 + 按钮Figure 3. 弹出窗口左侧 + 按钮点击 + 按钮之后，会弹出若干 configuration 的选项，选择 Go BuildFigure 4. configuration 的选项第 3 步Figure 5. configuration 的具体设置Name 是 configuration 的名字，与左侧的列表中的名字相对应，便于调试的时候进行选择。Run kind 包括 Directory, Package, File 几种类型Files 是真正需要去编译的文件，如果 Run kind 选择了 File，那么 Files 需要指定到某一个作为入口的 main.go 文件Environment 是环境变量。除了系统级别的环境变量意外，这里可以以 configuration 为单位设置环境变量，这样就更加灵活，互相之间不会干扰，也不会污染系统环境。多个环境变量之间用分号 ; 隔开Program arguments 是程序运行时需要的命令行参数第 4 步Figure 6. 创建好的 configurations选择一个 configuration，然后点击红色的按钮，即可开始调试调试 orderer入口位置orderer/main.go main 函数EnvironmentORDERER_GENERAL_LISTENADDRESS=0.0.0.0ORDERER_GENERAL_GENESISMETHOD=fileORDERER_GENERAL_GENESISFILE=fabric源码目录下dev-network/config/orderer.block(绝对路径)ORDERER_GENERAL_LOCALMSPID=DEFAULTORDERER_GENERAL_LOCALMSPDIR=fabric源码目录下dev-network/msp(绝对路径)FABRIC_CFG_PATH=fabric源码目录下dev-network(绝对路径)调试 peer start入口位置peer/main.go main 函数Program argumentsnode start --peer-chaincodedev=trueEnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=peerCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 create channel入口位置peer/main.go main 函数Program argumentschannel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050　　EnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 join channel入口位置peer/main.go main 函数Program argumentschannel join -b myc.blockEnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 install chaincode入口位置peer/main.go main 函数Program argumentschaincode install -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -n mycc -v 1.0　　EnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)其余部分待补充orderer 配置orderer 启动时，从 /orderer/main.go 入口/orderer/main.gofunc main() {\tserver.Main()}调用的是 ./orderer/common/server/main.go/orderer/common/server/main.gofunc Main() {\tfullCmd := kingpin.MustParse(app.Parse(os.Args[1:]))\t// \"version\" command\tif fullCmd == version.FullCommand() {\t\tfmt.Println(metadata.GetVersionInfo())\t\treturn\t}\tconf, err := localconfig.Load() (1)\tif err != nil {\t\tlogger.Error(\"failed to parse config: \", err)\t\tos.Exit(1)\t}\tinitializeLogging()\tinitializeLocalMsp(conf)\tprettyPrintStruct(conf)\tStart(fullCmd, conf)}1加载配置加载配置/orderer/common/localconfig/config.gofunc Load() (*TopLevel, error) {\tconfig := viper.New()\tcoreconfig.InitViper(config, \"orderer\") (1)\tconfig.SetEnvPrefix(Prefix) (2)\tconfig.AutomaticEnv() (3)\treplacer := strings.NewReplacer(\".\", \"_\")\tconfig.SetEnvKeyReplacer(replacer)\tif err := config.ReadInConfig(); err != nil {\t\treturn nil, fmt.Errorf(\"Error reading configuration: %s\", err)\t}\tvar uconf TopLevel\tif err := viperutil.EnhancedExactUnmarshal(config, &amp;uconf); err != nil {\t\treturn nil, fmt.Errorf(\"Error unmarshaling config into struct: %s\", err)\t}\tuconf.completeInitialization(filepath.Dir(config.ConfigFileUsed()))\treturn &amp;uconf, nil}1初始化一个 viper 实例，制定配置文件名字为 orderer2设置环境变量前缀，这里前缀是 ORDERER3自动读取 环境变量配置文件与环境变量的关系简单的说，环境变量会覆盖配置文件中的配置项，这样可以在不改变配置文件的前提下，做某些调整，非常方便，下面看下具体过程。进入 coreconfig.InitViper 内部/core/config/config.gofunc InitViper(v *viper.Viper, configName string) error {\tvar altPath = os.Getenv(\"FABRIC_CFG_PATH\") (1)\tif altPath != \"\" {\t\t// If the user has overridden the path with an envvar, its the only path\t\t// we will consider\t\tif !dirExists(altPath) {\t\t\treturn fmt.Errorf(\"FABRIC_CFG_PATH %s does not exist\", altPath)\t\t}\t\tAddConfigPath(v, altPath)\t} else {\t\t// If we get here, we should use the default paths in priority order:\t\t//\t\t// *) CWD\t\t// *) /etc/hyperledger/fabric\t\t// CWD\t\tAddConfigPath(v, \"./\")\t\t// And finally, the official path\t\tif dirExists(OfficialPath) {\t\t\tAddConfigPath(v, OfficialPath)\t\t}\t}\t// Now set the configuration file.\tif v != nil {\t\tv.SetConfigName(configName)\t} else {\t\tviper.SetConfigName(configName)\t}\treturn nil}1获取环境变量 FABRIC_CFG_PATH 的值FABRIC_CFG_PATH 指定了配置文件所在的位置，若未指定，则为当前文件夹viper 支持的配置文件扩展名有 7 种github.com/spf13/viper/viper.go// Universally supported extensions.var SupportedExts []string = []string{\"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\"}orderer 读取的是 orderer.yaml，以 GenesisMethod 为例，来看一下配置文件和环境变量的关系配置文件中 GenesisMethod 的值是 provisionalorderer.yamlGeneral:\t...\tGenesisMethod: provisional\t...环境变量配置中 GenesisMethod 的值是 file环境变量配置ORDERER_GENERAL_GENESISMETHOD=file环境变量命名规则 前缀_项_子项_以此类推，大写，orderer 配置文件的前缀是 orderer，General 的子项 GenesisMethod 按照规则来，就是 ORDERER_GENERAL_GENESISMETHODfabric 会先读取配置文件的内容，然后在环境变量中找相应的配置项，如果存在，环境变量会覆盖掉配置文件中的项环境变量覆盖配置文件项的位置github.com/spf13/viper/viper.gofunc (v *Viper) find(key string) interface{} {\t...\tif v.automaticEnvApplied { (1)\t\t// even if it hasn't been registered, if automaticEnv is used,\t\t// check any Get request\t\tif val = v.getEnv(v.mergeWithEnvPrefix(key)); val != \"\" {\t\t\tjww.TRACE.Println(key, \"found in environment with val:\", val)\t\t\treturn val\t\t}\t}\t...}1v.automaticEnvApplied 在方法 config.AutomaticEnv() 中被设置为 truecreate channel命令 peer channel create命令如下peer channel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050channel 是 peer 的子命令，create 是 channel 的子命令create channel 是 peer 节点执行的命令，入口处在 /peer/main.go/peer/main.gofunc main() {\t...\tmainCmd.AddCommand(channel.Cmd(nil)) (1)\t...}1为 mainCmd 添加了 channel 子命令mainCmd 就是 peervar mainCmd = &amp;cobra.Command{\tUse: \"peer\"}channel 里面什么样呢/peer/channel/channel.gofunc Cmd(cf *ChannelCmdFactory) *cobra.Command {\t...\tchannelCmd.AddCommand(createCmd(cf)) (1)\t...}1添加了 create 子命令createCmd 里面/peer/channel/create.gofunc createCmd(cf *ChannelCmdFactory) *cobra.Command {\tcreateCmd := &amp;cobra.Command{\t\tUse:   \"create\",\t\tShort: \"Create a channel\",\t\tLong:  \"Create a channel and write the genesis block to a file.\",\t\tRunE: func(cmd *cobra.Command, args []string) error {\t\t\treturn create(cmd, args, cf) (1)\t\t},\t}\tflagList := []string{\t\t\"channelID\",\t\t\"file\",\t\t\"outputBlock\",\t\t\"timeout\",\t}\tattachFlags(createCmd, flagList)\treturn createCmd}1create channel 实际执行的是 create 方法/peer/channel/create.gofunc create(cmd *cobra.Command, args []string, cf *ChannelCmdFactory) error {\t...\tif cf == nil {\t\tcf, err = InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererRequired) (1)\t\t...\t}\treturn executeCreate(cf)}1创建了一个 ChannelCmdFactory 对象看一下 ChannelCmdFactory 结构/peer/channel/channel.gotype ChannelCmdFactory struct {\tEndorserClient   pb.EndorserClient\tSigner           msp.SigningIdentity\tBroadcastClient  common.BroadcastClient (1)\tDeliverClient    deliverClientIntf\tBroadcastFactory BroadcastClientFactory (2)}1BroadcastClient 用来通信2BroadcastFactory 是一个方法，用来得到 BroadcastClient 对象/peer/common/broadcastclient.gotype BroadcastClient interface { (1)\tSend(env *cb.Envelope) error\tClose() error}type broadcastClient struct { (2)\tclient ab.AtomicBroadcast_BroadcastClient (3)}...func (s *broadcastClient) Send(env *cb.Envelope) error {\t...}func (s *broadcastClient) Close() error {\t...}1BroadcastClient 接口2broadcastClient 实现了 BroadcastClient 接口3真正完成 Send, Close 动作的是 ab.AtomicBroadcast_BroadcastClientgRPC 的使用AtomicBroadcast/protos/orderer/ab.proto 文件定义了 AtomicBroadcast 的原型protos/orderer/ab.proto...service AtomicBroadcast {    rpc Broadcast(stream common.Envelope) returns (stream BroadcastResponse) {}    rpc Deliver(stream common.Envelope) returns (stream DeliverResponse) {}}AtomicBroadcastClient/protos/orderer/ab.proto 经过 gPRC 编译后得到 /protos/orderer/ab.pb.go，里面包括 2 个部分  AtomicBroadcastClient，AtomicBroadcastServer，这里先看 AtomicBroadcastClient/protos/orderer/ab.pb.gotype AtomicBroadcastClient interface { (1)\tBroadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error)\tDeliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error)}type atomicBroadcastClient struct { (2)\tcc *grpc.ClientConn}func NewAtomicBroadcastClient(cc *grpc.ClientConn) AtomicBroadcastClient { (3)\treturn &amp;atomicBroadcastClient{cc}}func (c *atomicBroadcastClient) Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error) {\t...}type AtomicBroadcast_BroadcastClient interface { (4)\tSend(*common.Envelope) error\tRecv() (*BroadcastResponse, error)\tgrpc.ClientStream}type atomicBroadcastBroadcastClient struct { (5)\tgrpc.ClientStream}func (x *atomicBroadcastBroadcastClient) Send(m *common.Envelope) error {\t...}func (x *atomicBroadcastBroadcastClient) Recv() (*BroadcastResponse, error) {\t...}1AtomicBroadcastClient 接口2atomicBroadcastClient 实现了 AtomicBroadcastClient 接口3创建一个 atomicBroadcastClient 实例4AtomicBroadcast_BroadcastClient 接口是针对 AtomicBroadcastClient 中的 Broadcast 动作的客户端5atomicBroadcastBroadcastClient 实现了 AtomicBroadcast_BroadcastClient 接口AtomicBroadcast_DeliverClient 也是有的，与 AtomicBroadcast_BroadcastClient 类似，不再缀述OrdererClient/peer/common/ordererclient.gotype OrdererClient struct { (1)\tcommonClient}func NewOrdererClientFromEnv() (*OrdererClient, error) { (2)\taddress, override, clientConfig, err := configFromEnv(\"orderer\") (3)\t...}func (oc *OrdererClient) Broadcast() (ab.AtomicBroadcast_BroadcastClient, error) {\t...}func (oc *OrdererClient) Deliver() (ab.AtomicBroadcast_DeliverClient, error) {\t...}1OrdererClient 实现了 AtomicBroadcastClient 接口2NewOrdererClientFromEnv 创建了一 OrdererClient 实例3获取了关于 orderer 的配置，如地址，超时时间等前面提到过 InitCmdFactory 方法/peer/chaincode/common.gofunc InitCmdFactory(cmdName string, isEndorserRequired, isOrdererRequired bool) (*ChaincodeCmdFactory, error) {\t...\tif isOrdererRequired {\t\t...\t\tbroadcastClient, err = common.GetBroadcastClientFnc()\t\t...\t}\t...}/peer/chaincode/common.gofunc init() {\t...\tGetBroadcastClientFnc = GetBroadcastClient\t...}/peer/common/broadcastclient.gofunc GetBroadcastClient() (BroadcastClient, error) {\toc, err := NewOrdererClientFromEnv() (1)\t...}1调用了 OrdererClient 中的 NewOrdererClientFromEnv 方法消息的发出peer/channel/create.gofunc sendCreateChainTransaction(cf *ChannelCmdFactory) error {\t...\tdefer broadcastClient.Close()\terr = broadcastClient.Send(chCrtEnv) (1)\treturn err}1broadcastClient.Send 方法实际上调用了 gRPC，从 peer 节点发送消息给了 orderer 服务AtomicBroadcastServer/protos/orderer/ab.pb.gotype AtomicBroadcastServer interface {\tBroadcast(AtomicBroadcast_BroadcastServer) error\tDeliver(AtomicBroadcast_DeliverServer) error}func RegisterAtomicBroadcastServer(s *grpc.Server, srv AtomicBroadcastServer) { (1)\ts.RegisterService(&amp;_AtomicBroadcast_serviceDesc, srv)}func _AtomicBroadcast_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {\treturn srv.(AtomicBroadcastServer).Broadcast(&amp;atomicBroadcastBroadcastServer{stream}) (3)}...var _AtomicBroadcast_serviceDesc = grpc.ServiceDesc{\tServiceName: \"orderer.AtomicBroadcast\",\tHandlerType: (*AtomicBroadcastServer)(nil),\tMethods:     []grpc.MethodDesc{},\tStreams: []grpc.StreamDesc{\t\t{\t\t\tStreamName:    \"Broadcast\",\t\t\tHandler:       _AtomicBroadcast_Broadcast_Handler, (2)\t\t\tServerStreams: true,\t\t\tClientStreams: true,\t\t},\t\t{\t\t\tStreamName:    \"Deliver\",\t\t\tHandler:       _AtomicBroadcast_Deliver_Handler,\t\t\tServerStreams: true,\t\t\tClientStreams: true,\t\t},\t},\tMetadata: \"orderer/ab.proto\",}1注册 server 的方法2指定 Broadcast 的消息由 _AtomicBroadcast_Broadcast_Handler 方法来处理3真正处理消息的是 被注册的 server 对象的 Broadcast 方法/orderer/common/server/main.gofunc Start(cmd string, conf *localconfig.TopLevel) {\t...\tab.RegisterAtomicBroadcastServer(grpcServer.Server(), server) (1)\t...}1注册了 server这里的 server/orderer/common/server/server.gotype server struct { (1)\tbh    *broadcast.Handler\tdh    *deliver.Handler\tdebug *localconfig.Debug\t*multichannel.Registrar}...func (s *server) Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error {\tlogger.Debugf(\"Starting new Broadcast handler\")\tdefer func() {\t\tif r := recover(); r != nil {\t\t\tlogger.Criticalf(\"Broadcast client triggered panic: %s\\n%s\", r, debug.Stack())\t\t}\t\tlogger.Debugf(\"Closing Broadcast stream\")\t}()\treturn s.bh.Handle(&amp;broadcastMsgTracer{ (2)\t\tAtomicBroadcast_BroadcastServer: srv,\t\tmsgTracer: msgTracer{\t\t\tdebug:    s.debug,\t\t\tfunction: \"Broadcast\",\t\t},\t})}// Deliver sends a stream of blocks to a client after orderingfunc (s *server) Deliver(srv ab.AtomicBroadcast_DeliverServer) error {\t...}1server 实现了 AtomicBroadcastServer 接口2实际处理 client 端发出的强求的方法Handle 方法/orderer/common/broadcast/broadcast.gofunc (bh *Handler) Handle(srv ab.AtomicBroadcast_BroadcastServer) error {\t...\tfor {\t\t...\t\tresp := bh.ProcessMessage(msg, addr) (1)\t\t...\t}}1处理消息solo处理消息的方法/orderer/common/broadcast/broadcast.gofunc (bh *Handler) ProcessMessage(msg *cb.Envelope, addr string) (resp *ab.BroadcastResponse) {\t...\tif !isConfig {\t\t...\t\terr = processor.Order(msg, configSeq)\t\t...\t} else { // isConfig\t\t...\t\terr = processor.Configure(config, configSeq)\t\t...\t}\t...}processorprocessor 实际上是一个 Consenter 接口的实现/orderer/common/broadcast/broadcast.gotype Consenter interface {\tOrder(env *cb.Envelope, configSeq uint64) error\tConfigure(config *cb.Envelope, configSeq uint64) error\tWaitReady() error}此处实际工作的是 /orderer/consensus/solo/consensus.go 中的 chain/orderer/consensus/solo/consensus.gotype chain struct { (1)\tsupport  consensus.ConsenterSupport\tsendChan chan *message\texitChan chan struct{}}...func (ch *chain) WaitReady() error {\treturn nil}func (ch *chain) Order(env *cb.Envelope, configSeq uint64) error {\tselect {\tcase ch.sendChan &lt;- &amp;message{ (2)\t\tconfigSeq: configSeq,\t\tnormalMsg: env,\t}:\t\treturn nil\tcase &lt;-ch.exitChan:\t\treturn fmt.Errorf(\"Exiting\")\t}}func (ch *chain) Configure(config *cb.Envelope, configSeq uint64) error {\tselect {\tcase ch.sendChan &lt;- &amp;message{ (3)\t\tconfigSeq: configSeq,\t\tconfigMsg: config,\t}:\t\treturn nil\tcase &lt;-ch.exitChan:\t\treturn fmt.Errorf(\"Exiting\")\t}}1chain 实现了 Consenter 接口2Order 方法内部向 sendChan 发消息3Configure 方法内部向 sendChan 发消息处理消息的是 main 方法/orderer/consensus/solo/consensus.gofunc (ch *chain) main() {\t...\tfor {\t\tseq := ch.support.Sequence()\t\terr = nil\t\tselect {\t\tcase msg := &lt;-ch.sendChan: (1)\t\t\t...\t\tcase &lt;-timer:\t\t\t...\t\tcase &lt;-ch.exitChan:\t\t\t...\t\t}\t}1sendChan 收到消息时，处理为什么使用的是 solo 呢/orderer/common/server/main.gofunc Start(cmd string, conf *localconfig.TopLevel) {\t...\tmanager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback)\t...}...func initializeMultichannelRegistrar(\tbootstrapBlock *cb.Block,\tri *replicationInitiator,\tclusterDialer *cluster.PredicateDialer,\tsrvConf comm.ServerConfig,\tsrv *comm.GRPCServer,\tconf *localconfig.TopLevel,\tsigner crypto.LocalSigner,\tmetricsProvider metrics.Provider,\thealthChecker healthChecker,\tlf blockledger.Factory,\tcallbacks ...channelconfig.BundleActor,) *multichannel.Registrar {\tgenesisBlock := extractBootstrapBlock(conf)\t...\tconsenters := make(map[string]consensus.Consenter)\tregistrar := multichannel.NewRegistrar(lf, signer, metricsProvider, callbacks...)\tconsenters[\"solo\"] = solo.New() (1)\tvar kafkaMetrics *kafka.Metrics\tconsenters[\"kafka\"], kafkaMetrics = kafka.New(conf.Kafka, metricsProvider, healthChecker) (2)\t...\tregistrar.Initialize(consenters)\treturn registrar}1创建 solo 共识器2创建 kafka 共识器/orderer/common/multichannel/registrar.gofunc (r *Registrar) Initialize(consenters map[string]consensus.Consenter) {\tr.consenters = consenters\texistingChains := r.ledgerFactory.ChainIDs()\tfor _, chainID := range existingChains {\t\t...\t\tif _, ok := ledgerResources.ConsortiumsConfig(); ok {\t\t\t...\t\t\tchain := newChainSupport( (1)\t\t\t\tr,\t\t\t\tledgerResources,\t\t\t\tr.consenters,\t\t\t\tr.signer,\t\t\t\tr.blockcutterMetrics,\t\t\t)\t\t\t...\t\t} else {\t\t\t...\t\t}\t}\t...}1调用 newChainSupport 方法/orderer/common/multichannel/chainsupport.gofunc newChainSupport(\tregistrar *Registrar,\tledgerResources *ledgerResources,\tconsenters map[string]consensus.Consenter,\tsigner crypto.LocalSigner,\tblockcutterMetrics *blockcutter.Metrics,) *ChainSupport {\t...\tconsenterType := ledgerResources.SharedConfig().ConsensusType() (1)\tconsenter, ok := consenters[consenterType] (2)\t...}1获取 共识器 类型，这里实际的值是 solo2根据 共识器 类型来决定使用哪种共识器orderer genesisblock/orderer/common/server/main.gofunc Start(cmd string, conf *localconfig.TopLevel) {\tbootstrapBlock := extractBootstrapBlock(conf) (1)    ...\tlf, _ := createLedgerFactory(conf, metricsProvider) (2)    ...    manager := initializeMultichannelRegistrar(clusterBootBlock, r, clusterDialer, clusterServerConfig, clusterGRPCServer, conf, signer, metricsProvider, opsSystem, lf, tlsCallback) (3)}1读取创世块信息2创建账本文件夹3创建默认 channel读取创世块信息/orderer/common/server/main.gofunc extractBootstrapBlock(conf *localconfig.TopLevel) *cb.Block {\tvar bootstrapBlock *cb.Block\t// Select the bootstrapping mechanism\tswitch conf.General.GenesisMethod {\tcase \"provisional\":\t\tbootstrapBlock = encoder.New(genesisconfig.Load(conf.General.GenesisProfile)).GenesisBlockForChannel(conf.General.SystemChannel)\tcase \"file\":\t\tbootstrapBlock = file.New(conf.General.GenesisFile).GenesisBlock() (1)\tdefault:\t\tlogger.Panic(\"Unknown genesis method:\", conf.General.GenesisMethod)\t}\treturn bootstrapBlock}1读取了配置项 General.GenesisFile 所指定的文件的内容创建账本文件夹/orderer/common/server/util.gofunc createLedgerFactory(conf *config.TopLevel, metricsProvider metrics.Provider) (blockledger.Factory, string) {\tvar lf blockledger.Factory\tvar ld string\tswitch conf.General.LedgerType {\tcase \"file\":\t\tld = conf.FileLedger.Location (1)        ...        lf = fileledger.New(ld, metricsProvider) (2)        ...\t\tcreateSubDir(ld, fsblkstorage.ChainsDir) (3)    ...}1读取了配置项 FileLedger.Location2按 FileLedger.Location 的值，创建了文件夹，并在其下创建了一个 leveldb 的数据库 index3在 FileLedger.Location 下面创建了 channel 的父文件夹 chains创建默认 channel缩写Table 1. 缩写缩写描述MSPMembership service provider 会员服务提供者BCCSPblockchain（前两个字母BC） cryptographic service provider 区域链加密服务提供者abatomic broadcast原子（操作）广播lscclifecycle(L) system(S) chaincode（CC）生命周期系统链码SpecSpecification，规格标准，详细说明KVkey-value 键-值CDSChaincodeDeploymentSpecCISChaincodeInvocationSpecmgmtmanagementSWsoftware-basedABAtomicBroadcastGBgenesis block，创世纪的block，也就是区域链中的第一个块CC或ccchaincodeSCC或sccsystem chaincodecsccconfiger system chaincodelscclifecycle system chaincodeesccendorser system chaincodevsccvalidator system chaincodeqsccquerier system chaincodealgalgorithm 算法mcsmspMessageCryptoServicemock假装，学样子，模仿的意思，基本上是服务于xxx_test.go的，即用于测试的Gossip一种使分布结点达到状态最终一致的算法attrattributeFsBlockStorefile system block storevdbversioned database 也就是状态数据库RTEnvruntime environment运行环境pkcs11pcks#11，一种公匙加密标准，有一套叫做Cryptoki的接口，是一组平台设备无关的APIMCSmspMessageCryptoService，消息加密服务saSecurityAdvisorimplimplement，好多处XXX.go和XXXimpl.go是对应的，前者是用于接口或者定义的，后者是实现该接口或定义的FSMfinite state machine 有限状态机FSfilesystem 文件系统blkblockclicommand line interface 命令行界面CFGFABRIC_CFG_PATH中的，应该是config的意思mgrmanagercpinfocheckpoint information，检查点信息DevModedevelopment mode，开发模式Regregister，注册，登记hdrheaderimplimplementoidObjectIdentifier，对象标识符ou或OUorganizational unitCRLcertificate revocation list，废除证书列表propproposal，申请，交易所发送的申请ACLAccess Control List，访问控制列表rwsetread/write set，读写集tx，Txtransaction，交易CSPcryptographic service provider，BCCSP的后三个字母，加密服务提供者optoption，选项optsoptions，多个选项SKI当前证书标识，所谓标识，一般是对公匙进行一下hashAKI签署方的SKI，也就是签署方的公匙标识HSMHardware Security ModulesksKeyStore，Key存储，这个key指的是用于签名的公匙私匙oidOBJECT IDENTIFIER，对象身份标识来源于网络，待整理确认目录Table 2. 目录bcssp加密服务代码目录common全局公用代码目录core核心功能代码目录docs以.rst文件为核心，可编译生成文档。说明文档的目录events事件代码目录，用于生产和消费信息examples示例目录gossip本意是绯闻的意思，是一种可达到去中心化，有一定容错能力且可达到最终一致的传播算法msp会员服务代码目录orderer就理解成orderer目录就好，orderer也算是区域链中的专用名词，用于消息的订阅与分发处理protos原型目录，定义个各种原型和生成的对应的XXX.pb.go源码vendor原意是商贩，在此就是存放go中使用的全部的各种第三方包来源于网络，待整理确认peerFigure 7. peer 命令结构jwwjww 全称 jwalterweatherman，源码在 github特点可同时进行 terminal 输出 和 日志记录可分别进行级别控制级别TRACEDEBUGINFOWARNERRORCRITICALFATALconst (\tLevelTrace Threshold = iota\tLevelDebug\tLevelInfo\tLevelWarn\tLevelError\tLevelCritical\tLevelFatal)通过源码可以看到，级别是个枚举，其对应的数值由 0 至 6 逐渐增大。 默认情况下:Trace, Debug, Info 对应的是 devNull，即被忽略Warn 及以上，会被写入日志(如果提供了日志文件的话)Error 及以上会被打印到 terminaldevNull 是什么?devNull 的部分代码type devNull intfunc (devNull) Write(p []byte) (int, error) {\treturn len(p), nil}从代码可以看出，devNull 是 io.Writer 的实现，其 Write 方法内部没有做任何 写 的操作，从而达到了 忽略 的效果示例github.com/spf13/viper/util.gofunc absPathify(inPath string) string {\tjww.INFO.Println(\"Trying to resolve absolute path to\", inPath) (1)\tif strings.HasPrefix(inPath, \"$HOME\") {\t\tinPath = userHomeDir() + inPath[5:]\t}\tif strings.HasPrefix(inPath, \"$\") {\t\tend := strings.Index(inPath, string(os.PathSeparator))\t\tinPath = os.Getenv(inPath[1:end]) + inPath[end:]\t}\tif filepath.IsAbs(inPath) {\t\treturn filepath.Clean(inPath)\t}\tp, err := filepath.Abs(inPath)\tif err == nil {\t\treturn filepath.Clean(p)\t} else {\t\tjww.ERROR.Println(\"Couldn't discover absolute path\") (2)\t\tjww.ERROR.Println(err) (3)\t}\treturn \"\"}1INFO 级别2ERROR 级别3ERROR 级别意义是什么?以 viper 这个库为例，如果\b不做级别设置，那么日志只记录 Warn 及以上级别的信息，terminal 只输出 Error 及以上级别的信息，换言之，是有了一定的错误的时候。但是如果我们代码中，在使用 viper 的时候，出现了问题，我们想知道更多细节，就可以打出更多级别的消息。比如:jww.SetStdoutThreshold(jww.LevelTrace) (1)jww.SetLogThreshold(jww.LevelTrace) (2)1设置 terminal 输出级别为 Trace2设置 log 输出级别为 Trace这样，就可以打印出所有消息，按需输出，这种方式很灵活。kingpinkingpin 是命令行的参数，Flag 的 parser示例 1源码 1package mainimport (    \"fmt\"    \"gopkg.in/alecthomas/kingpin.v2\")var (    debug   = kingpin.Flag(\"debug\", \"Enable debug mode.\").Bool()    timeout = kingpin.Flag(\"timeout\", \"Timeout waiting for ping.\").Default(\"5s\").OverrideDefaultFromEnvar(\"PING_TIMEOUT\").Short('t').Duration()    ip      = kingpin.Arg(\"ip\", \"IP address to ping.\").Required().IP()    count   = kingpin.Arg(\"count\", \"Number of packets to send\").Int())func main() {    kingpin.Version(\"0.0.1\")    kingpin.Parse()    fmt.Printf(\"Would ping: %s with timeout %s and count %d\\n\", *ip, *timeout, *count)}效果 1$ ping --helpusage: ping [&lt;flags&gt;] &lt;ip&gt; [&lt;count&gt;]Flags:  --debug            Enable debug mode.  --help             Show help.  -t, --timeout=5s   Timeout waiting for ping.Args:  &lt;ip&gt;        IP address to ping.  [&lt;count&gt;]   Number of packets to send$ ping 1.2.3.4 5Would ping: 1.2.3.4 with timeout 5s and count 5示例 2源码 2package mainimport (    \"os\"    \"strings\"    \"gopkg.in/alecthomas/kingpin.v2\")var (    app      = kingpin.New(\"chat\", \"A command-line chat application.\")    debug    = app.Flag(\"debug\", \"Enable debug mode.\").Bool()    serverIP = app.Flag(\"server\", \"Server address.\").Default(\"127.0.0.1\").IP()    register     = app.Command(\"register\", \"Register a new user.\")    registerNick = register.Arg(\"nick\", \"Nickname for user.\").Required().String()    registerName = register.Arg(\"name\", \"Name of user.\").Required().String()    post        = app.Command(\"post\", \"Post a message to a channel.\")    postImage   = post.Flag(\"image\", \"Image to post.\").File()    postChannel = post.Arg(\"channel\", \"Channel to post to.\").Required().String()    postText    = post.Arg(\"text\", \"Text to post.\").Strings())func main() {    switch kingpin.MustParse(app.Parse(os.Args[1:])) {    // Register user    case register.FullCommand():        println(*registerNick)    // Post message    case post.FullCommand():        if *postImage != nil {        }        text := strings.Join(*postText, \" \")        println(\"Post:\", text)    }}效果 2$ chat --helpusage: chat [&lt;flags&gt;] &lt;command&gt; [&lt;flags&gt;] [&lt;args&gt; ...]A command-line chat application.Flags:  --help              Show help.  --debug             Enable debug mode.  --server=127.0.0.1  Server address.Commands:  help [&lt;command&gt;]    Show help for a command.  register &lt;nick&gt; &lt;name&gt;    Register a new user.  post [&lt;flags&gt;] &lt;channel&gt; [&lt;text&gt;]    Post a message to a channel.$ chat help postusage: chat [&lt;flags&gt;] post [&lt;flags&gt;] &lt;channel&gt; [&lt;text&gt;]Post a message to a channel.Flags:  --image=IMAGE  Image to post.Args:  &lt;channel&gt;  Channel to post to.  [&lt;text&gt;]   Text to post.$ chat post --image=~/Downloads/owls.jpg pics...",
                        "url": "/allposts/all/all"
                    }
                    ,
                
                    "allposts-debug-overview": {
                        "title": "概览",
                        "author": "",
                        "category": "",
                        "content": "Table of Contents概览准备工作步骤调试准备第 1 步第 2 步第 3 步第 4 步调试 orderer调试 peer start调试 create channel调试 join channel调试 install chaincode概览准备工作fabric 源码，fabric-samples 源码GoLand (golang IDE)步骤用 GoLand 打开 fabric 源码新建 dev-network 目录把 sampleconfig 下的所有文件复制到 dev-network修改 core.yaml 中 fileSystemPath = fabric源码目录下dev-network/production/peer(绝对路径)修改 orderer.yaml 中 Location = fabric源码目录下dev-network/production/orderer(绝对路径)在 dev-network 新建 config，并复制 fabric-samples 模块 chaincode-docker-devmode下的 myc.tx 和 orderer.block调试准备第 1 步点击菜单项 Run/Edit ConfigurationsFigure 1. 点击菜单项 Run/Edit Configurations第 2 步点击弹出窗口左上交的 + 按钮Figure 2. 弹出窗口左侧 + 按钮点击 + 按钮之后，会弹出若干 configuration 的选项，选择 Go BuildFigure 3. configuration 的选项第 3 步Figure 4. configuration 的具体设置Name 是 configuration 的名字，与左侧的列表中的名字相对应，便于调试的时候进行选择。Run kind 包括 Directory, Package, File 几种类型Files 是真正需要去编译的文件，如果 Run kind 选择了 File，那么 Files 需要指定到某一个作为入口的 main.go 文件Environment 是环境变量。除了系统级别的环境变量意外，这里可以以 configuration 为单位设置环境变量，这样就更加灵活，互相之间不会干扰，也不会污染系统环境。多个环境变量之间用分号 ; 隔开Program arguments 是程序运行时需要的命令行参数第 4 步Figure 5. 创建好的 configurations选择一个 configuration，然后点击红色的按钮，即可开始调试调试 orderer入口位置orderer/main.go main 函数EnvironmentORDERER_GENERAL_LISTENADDRESS=0.0.0.0ORDERER_GENERAL_GENESISMETHOD=fileORDERER_GENERAL_GENESISFILE=fabric源码目录下dev-network/config/orderer.block(绝对路径)ORDERER_GENERAL_LOCALMSPID=DEFAULTORDERER_GENERAL_LOCALMSPDIR=fabric源码目录下dev-network/msp(绝对路径)FABRIC_CFG_PATH=fabric源码目录下dev-network(绝对路径)调试 peer start入口位置peer/main.go main 函数Program argumentsnode start --peer-chaincodedev=trueEnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=peerCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 create channel入口位置peer/main.go main 函数Program argumentschannel create -c myc -f fabric源码目录下dev-network/config/myc.tx(绝对路径) -o 127.0.0.1:7050　　EnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 join channel入口位置peer/main.go main 函数Program argumentschannel join -b myc.blockEnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)调试 install chaincode入口位置peer/main.go main 函数Program argumentschaincode install -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -n mycc -v 1.0　　EnvironmentCORE_PEER_LOCALMSPID=DEFAULTCORE_PEER_ID=cliCORE_PEER_MSPCONFIGPATH=fabric源码目录下dev-network/msp(绝对路径)CORE_PEER_ADDRESS=127.0.0.1:7051FABRIC_CFG_PATH=fabric源码目录下/dev-network(绝对路径)其余部分待补充",
                        "url": "/allposts/debug/overview"
                    }
                    ,
                
                    "allposts-source-peer": {
                        "title": "peer",
                        "author": "",
                        "category": "",
                        "content": "Table of ContentspeerpeerFigure 1. peer 命令结构",
                        "url": "/allposts/source/peer"
                    }
                    ,
                
                    "allposts-source-directory": {
                        "title": "目录",
                        "author": "",
                        "category": "",
                        "content": "Table of Contents目录目录Table 1. 目录bcssp加密服务代码目录common全局公用代码目录core核心功能代码目录docs以.rst文件为核心，可编译生成文档。说明文档的目录events事件代码目录，用于生产和消费信息examples示例目录gossip本意是绯闻的意思，是一种可达到去中心化，有一定容错能力且可达到最终一致的传播算法msp会员服务代码目录orderer就理解成orderer目录就好，orderer也算是区域链中的专用名词，用于消息的订阅与分发处理protos原型目录，定义个各种原型和生成的对应的XXX.pb.go源码vendor原意是商贩，在此就是存放go中使用的全部的各种第三方包来源于网络，待整理确认",
                        "url": "/allposts/source/directory"
                    }
                    ,
                
                    "allposts-source-abbreviation": {
                        "title": "缩写",
                        "author": "",
                        "category": "",
                        "content": "Table of Contents缩写缩写Table 1. 缩写缩写描述MSPMembership service provider 会员服务提供者BCCSPblockchain（前两个字母BC） cryptographic service provider 区域链加密服务提供者abatomic broadcast原子（操作）广播lscclifecycle(L) system(S) chaincode（CC）生命周期系统链码SpecSpecification，规格标准，详细说明KVkey-value 键-值CDSChaincodeDeploymentSpecCISChaincodeInvocationSpecmgmtmanagementSWsoftware-basedABAtomicBroadcastGBgenesis block，创世纪的block，也就是区域链中的第一个块CC或ccchaincodeSCC或sccsystem chaincodecsccconfiger system chaincodelscclifecycle system chaincodeesccendorser system chaincodevsccvalidator system chaincodeqsccquerier system chaincodealgalgorithm 算法mcsmspMessageCryptoServicemock假装，学样子，模仿的意思，基本上是服务于xxx_test.go的，即用于测试的Gossip一种使分布结点达到状态最终一致的算法attrattributeFsBlockStorefile system block storevdbversioned database 也就是状态数据库RTEnvruntime environment运行环境pkcs11pcks#11，一种公匙加密标准，有一套叫做Cryptoki的接口，是一组平台设备无关的APIMCSmspMessageCryptoService，消息加密服务saSecurityAdvisorimplimplement，好多处XXX.go和XXXimpl.go是对应的，前者是用于接口或者定义的，后者是实现该接口或定义的FSMfinite state machine 有限状态机FSfilesystem 文件系统blkblockclicommand line interface 命令行界面CFGFABRIC_CFG_PATH中的，应该是config的意思mgrmanagercpinfocheckpoint information，检查点信息DevModedevelopment mode，开发模式Regregister，注册，登记hdrheaderimplimplementoidObjectIdentifier，对象标识符ou或OUorganizational unitCRLcertificate revocation list，废除证书列表propproposal，申请，交易所发送的申请ACLAccess Control List，访问控制列表rwsetread/write set，读写集tx，Txtransaction，交易CSPcryptographic service provider，BCCSP的后三个字母，加密服务提供者optoption，选项optsoptions，多个选项SKI当前证书标识，所谓标识，一般是对公匙进行一下hashAKI签署方的SKI，也就是签署方的公匙标识HSMHardware Security ModulesksKeyStore，Key存储，这个key指的是用于签名的公匙私匙oidOBJECT IDENTIFIER，对象身份标识来源于网络，待整理确认",
                        "url": "/allposts/source/abbreviation"
                    }
                    ,
                
                    "allposts-principle-workflow": {
                        "title": "工作流程",
                        "author": "",
                        "category": "",
                        "content": "Table of Contents工作流程工作流程Figure 1. 交易流程时序图交易流程(1)客户端通过 SDK 接口向 背书节点 发送交易信息(2)每个 背书节点 模拟处理交易，并不会把交易信息写入账本。背书节点 会验证交易的合法性，并对交易签名，返回给 client。此时没有完成全网共识，各个 client 的交易顺序没有确定，可能存在 双花 问题，还不算是 \"有效的交易\"。(3)client 将签名后的交易发送给 order servic 集群进行交易排序和打包。order servic 集群通过共识算法对交易进行排序，打包成区块。(4)order servic 将打包后的区块广播发送给 提交节点，由其做最后的验证，并写入链。order servic 在发给 提交节点 的同时，是否也发给了 背书节点 ? 待确认",
                        "url": "/allposts/principle/workflow"
                    }
                    
                
            };

            $("#search_box").keyup(function() {
                var searchTerm = $("#search_box").val();
                if (searchTerm.length === 0) {
                    $("#content").show()
                    $("#search_result_container").hide()
                } else {
                    $("#search_result_container").show()
                    $("#content").hide()
                    search();
                }
            });

            $("#search_box").blur(function() {
                $("#content").show()
                $("#search_result_container").hide()
            });

            $("code").each(function() {
                let $this = $(this);
                var html = $this.html()

                // replace tab with 4 spaces
                html = html.replace(/\t/g, "    ")
                $this.html(html)
            })
        </script>
        <script src="/js/prettify.min.js"></script>
        <script>
            prettyPrint();
        </script>
    </body>
</html>
